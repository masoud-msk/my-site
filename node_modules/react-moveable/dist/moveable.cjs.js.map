{"version":3,"file":"moveable.cjs.js","sources":["../src/react-moveable/consts.ts","../src/react-moveable/utils.ts","../src/react-moveable/ables/triggerRender.ts","../src/react-moveable/getAbleDragger.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/CustomDragger.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/DraggerUtils.ts","../src/react-moveable/ables/utils.ts","../src/react-moveable/ables/snappable/snap.ts","../src/react-moveable/ables/snappable/innerBounds.ts","../src/react-moveable/ables/snappable/bounds.ts","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/ables/Draggable.tsx","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/renderDirection.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/Default.ts","../src/react-moveable/ables/Padding.tsx","../src/react-moveable/ables/consts.ts","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/Moveable.tsx"],"sourcesContent":["import { prefixCSS } from \"framework-utils\";\nimport getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    const defaultCursor\n        = degree45 === 135\n        ? \"nwse-resize\"\n        : degree45 === 45\n        ? \"nesw-resize\"\n        : degree45 === 90\n        ? \"ew-resize\"\n        : \"ns-resize\"; // 135\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};cursor: -webkit-image-set(url('${x1}') 1x, url('${x2}') 2x) 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent();\nexport const IS_WEBKIT\n    = agent.os.name.indexOf(\"ios\") > -1 || agent.browser.name.indexOf(\"safari\") > -1;\n\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = prefixCSS(PREFIX, `\n{\n\tposition: fixed;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --zoom: 1;\n    --zoompx: 1px;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\tposition: absolute;\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n\tbackground: #4af;\n\tmargin-top: -7px;\n    margin-left: -7px;\n    width: calc(14 * var(--zoompx));\n    height: calc(14 * var(--zoompx));\n    margin-top: calc(-7 * var(--zoompx));\n    margin-left: calc(-7 * var(--zoompx));\n    border: calc(2 * var(--zoompx)) solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\tposition: absolute;\n\twidth: 1px;\n    height: 1px;\n    width: var(--zoompx);\n    height: var(--zoompx);\n\tbackground: #4af;\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top: var(--zoompx) dashed #4af;\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left: var(--zoompx) dashed #4af;\n}\n.line.dashed:before {\n    position: absolute;\n    content: attr(data-size);\n    color: #4af;\n    font-size: 12px;\n    font-weight: bold;\n}\n.line.dashed.horizontal:before, .line.gap.horizontal:before {\n    left: 50%;\n    transform: translateX(-50%);\n    bottom: 5px;\n}\n.line.dashed.vertical:before, .line.gap.vertical:before {\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.line.rotation-line {\n\theight: 40px;\n    width: 1px;\n    transform-origin: 50% calc(100% - 0.5px);\n    top: -40px;\n    width: var(--zoompx);\n    height: calc(40 * var(--zoompx));\n    top: calc(-40 * var(--zoompx));\n    transform-origin: 50% calc(100% - 0.5 * var(--zoompx));\n}\n.line.rotation-line .control {\n\tborder-color: #4af;\n\tbackground:#fff;\n    cursor: alias;\n    left: 50%;\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n    width: calc(2 * var(--zoompx));\n}\n.line.horizontal.bold {\n    height: 2px;\n    height: calc(2 * var(--zoompx));\n}\n\n.line.gap {\n    background: #f55;\n}\n.line.gap:before {\n    position: absolute;\n    content: attr(data-size);\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n    width: calc(12 * var(--zoompx));\n    height: calc(12 * var(--zoompx));\n    margin-top: calc(-6 * var(--zoompx));\n    margin-left: calc(-6 * var(--zoompx));\n\tpointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"] {\n\t${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: pointer;\n}\n${IS_WEBKIT ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`);\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTIONS = [\"nw\", \"ne\", \"sw\", \"se\", \"n\", \"w\", \"s\", \"e\"];\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    s: [2, 3],\n    w: [2, 0],\n    e: [1, 3],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n","import { PREFIX, IS_WEBKIT } from \"./consts\";\nimport { prefixNames } from \"framework-utils\";\nimport { splitBracket, isUndefined, isObject, splitUnit, IObject } from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertCSStoMatrix, convertMatrixtoCSS,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, caculate,\n    multiplies,\n    minus,\n    getOrigin,\n    createScaleMatrix,\n    plus,\n    getRad,\n    ignoreDimension,\n} from \"@moveable/matrix\";\n\nimport MoveableManager from \"./MoveableManager\";\nimport { MoveableManagerState, Able, MoveableClientRect, MoveableProps } from \"./types\";\n\nexport function round(num: number) {\n    return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransform(target: SVGElement | HTMLElement, isInit: true): number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: false): \"none\" | number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: boolean) {\n    const transform = getComputedStyle(target).transform!;\n\n    if (!transform || (transform === \"none\" && !isInit)) {\n        return \"none\";\n    }\n    return getTransformMatrix(transform);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    const value = splitBracket(transform).value!;\n    return value.split(/s*,\\s*/g).map(v => parseFloat(v));\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = getSVGViewBox(el.ownerSVGElement!);\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent ? el : el.parentElement;\n    let isEnd = false;\n    let position = \"relative\";\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const transform = style.transform;\n        position = style.position!;\n\n        if (position !== \"static\" || (transform && transform !== \"none\")) {\n            break;\n        }\n        target = target.parentElement;\n        position = \"relative\";\n    }\n    return {\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function getOffsetPosInfo(\n    el: HTMLElement | SVGElement,\n    container: SVGElement | HTMLElement | null,\n    style: CSSStyleDeclaration,\n    isFixed: boolean,\n) {\n    const tagName = el.tagName.toLowerCase();\n    let offsetLeft = (el as HTMLElement).offsetLeft;\n    let offsetTop = (el as HTMLElement).offsetTop;\n\n    if (isFixed) {\n        const containerClientRect = (container || document.documentElement).getBoundingClientRect();\n\n        offsetLeft -= containerClientRect.left;\n        offsetTop -= containerClientRect.top;\n    }\n    // svg\n    const isSVG = isUndefined(offsetLeft);\n    let hasOffset = !isSVG;\n    let origin: number[];\n    // inner svg element\n    if (!hasOffset && tagName !== \"svg\") {\n        origin = IS_WEBKIT\n            ? getBeforeTransformOrigin(el as SVGElement)\n            : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n        hasOffset = true;\n\n        if (tagName === \"g\") {\n            offsetLeft = 0;\n            offsetTop = 0;\n        } else {\n            [\n                offsetLeft, offsetTop, origin[0], origin[1],\n            ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n        }\n    } else {\n        origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n    }\n    return {\n        isSVG,\n        hasOffset,\n        offset: [offsetLeft, offsetTop],\n        origin,\n    };\n}\nexport function getMatrixStackInfo(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n) {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: number[][] = [];\n    let isEnd = false;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    const offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n    if (prevMatrix) {\n        isEnd = target === container;\n        if (prevMatrix.length > 10) {\n            is3d = true;\n            n = 4;\n        }\n        container = target.parentElement;\n    }\n\n    while (el && !isEnd) {\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const tagName = el.tagName.toLowerCase();\n        const position = style.position;\n        const isFixed = position === \"fixed\";\n        const styleTransform = style.transform!;\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(styleTransform));\n\n        // convert 3 to 4\n        const length = matrix.length;\n        if (!is3d && length === 16) {\n            is3d = true;\n            n = 4;\n            const matrixesLength = matrixes.length;\n\n            for (let i = 0; i < matrixesLength; ++i) {\n                matrixes[i] = convertDimension(matrixes[i], 3, 4);\n            }\n        }\n        if (is3d &&  length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n        const {\n            hasOffset,\n            isSVG,\n            origin,\n            offset: offsetPos,\n        } = getOffsetPosInfo(el, container, style, isFixed);\n        let [\n            offsetLeft,\n            offsetTop,\n        ] = offsetPos;\n        if (tagName === \"svg\" && targetMatrix) {\n            matrixes.push(\n                // scale matrix for svg's SVGElements.\n                getSVGMatrix(el as SVGSVGElement, n),\n                createIdentityMatrix(n),\n            );\n        }\n        const {\n            offsetParent,\n            isEnd: isOffsetEnd,\n            isStatic,\n        } = getOffsetInfo(el, container);\n\n        if (IS_WEBKIT && hasOffset && !isSVG && isStatic && position === \"relative\") {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            isEnd = isEnd || isOffsetEnd;\n        }\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n\n        if (hasOffset && offsetContainer !== offsetParent) {\n            // border\n            parentClientLeft = offsetParent.clientLeft;\n            parentClientTop = offsetParent.clientTop;\n        }\n        matrixes.push(\n            // absolute matrix\n            getAbsoluteMatrix(matrix, n, origin),\n            // offset matrix (offsetPos + clientPos(border))\n            createOriginMatrix(hasOffset ? [\n                offsetLeft - el.scrollLeft + parentClientLeft,\n                offsetTop - el.scrollTop + parentClientTop,\n            ] : [el, origin] as any, n),\n        );\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            isEnd = isOffsetEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [0, 0];\n    }\n    return {\n        offsetContainer,\n        matrixes,\n        targetMatrix,\n        transformOrigin,\n        is3d,\n    };\n}\nexport function caculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n    prevRootMatrix?: number[],\n    prevN?: number,\n): [number[], number[], number[], number[], number[], string, number[], boolean] {\n    const {\n        matrixes,\n        is3d,\n        targetMatrix: prevTargetMatrix,\n        transformOrigin,\n        offsetContainer,\n    } = getMatrixStackInfo(target, container, prevMatrix);\n    const {\n        matrixes: rootMatrixes,\n        is3d: isRoot3d,\n    } = getMatrixStackInfo(offsetContainer, rootContainer, prevRootMatrix);\n\n    const n = isRoot3d || is3d ? 4 : 3;\n    const isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n    const originalContainer = container || document.body;\n    let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let targetMatrix = prevTargetMatrix;\n    let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n    let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n    const endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;\n\n    rootMatrixes.reverse();\n    matrixes.reverse();\n\n    if (!is3d && isRoot3d) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n        matrixes.forEach((matrix, i) => {\n            matrixes[i] = convertDimension(matrix, 3, 4);\n        });\n    }\n    if (is3d && !isRoot3d) {\n        rootMatrixes.forEach((matrix, i) => {\n            rootMatrixes[i] = convertDimension(matrix, 3, 4);\n        });\n    }\n\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n    if (!prevRootMatrix) {\n        rootMatrixes.forEach(matrix => {\n            rootMatrix = multiply(rootMatrix, matrix, n);\n        });\n    }\n    matrixes.forEach((matrix, i) => {\n        if (length - 2 === i) {\n            // length - 3\n            beforeMatrix = allMatrix.slice();\n        }\n        if (length - 1 === i) {\n            // length - 2\n            offsetMatrix = allMatrix.slice();\n        }\n\n        // caculate for SVGElement\n        if (isObject(matrix[n - 1])) {\n            [matrix[n - 1], matrix[2 * n - 1]] =\n                getSVGOffset(\n                    matrix[n - 1] as any,\n                    endContainer,\n                    n,\n                    matrix[2 * n - 1] as any,\n                    allMatrix,\n                    matrixes[i + 1],\n                );\n        }\n        allMatrix = multiply(allMatrix, matrix, n);\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n    }\n    const transform = `${isMatrix3d ? \"matrix3d\" : \"matrix\"}(${\n        convertMatrixtoCSS(isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix)\n        })`;\n\n    rootMatrix = ignoreDimension(rootMatrix, n, n);\n    return [\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        allMatrix,\n        targetMatrix,\n        transform,\n        transformOrigin,\n        is3d || isRoot3d,\n    ];\n}\nexport function getSVGViewBox(el: SVGSVGElement) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const viewBox = el.viewBox;\n    const baseVal = (viewBox && viewBox.baseVal) || { x: 0, y: 0, width: 0, height: 0 };\n\n    return {\n        x: baseVal.x,\n        y: baseVal.y,\n        width: baseVal.width || clientWidth,\n        height: baseVal.height || clientHeight,\n    };\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const {\n        width: viewBoxWidth,\n        height: viewBoxHeight,\n    } = getSVGViewBox(el);\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = el.preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n - 1],\n        scaleMatrix[2 * n - 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox) {\n        return [0, 0];\n    }\n    const bbox = el.getBBox();\n    const viewBox = getSVGViewBox(el.ownerSVGElement!);\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function caculatePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function caculatePoses(matrix: number[], width: number, height: number, n: number) {\n    return [[0, 0], [width, 0], [0, height], [width, height]].map(pos => caculatePosition(matrix, pos, n));\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function caculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = caculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    el: SVGElement,\n    container: HTMLElement | SVGElement,\n    n: number, origin: number[], beforeMatrix: number[], absoluteMatrix: number[]) {\n\n    const [width, height] = getSize(el);\n    const containerClientRect = container.getBoundingClientRect();\n    const rect = el.getBoundingClientRect();\n    const rectLeft = rect.left - containerClientRect.left + container.scrollLeft;\n    const rectTop = rect.top - containerClientRect.top + container.scrollTop;\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        absoluteMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = caculateRect(mat, width, height, n);\n    const posOrigin = caculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            caculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            caculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            absoluteMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = caculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\nexport function caculateMoveablePosition(matrix: number[], origin: number[], width: number, height: number): [\n    number[],\n    number[],\n    number[][],\n    1 | -1,\n] {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = caculatePoses(matrix, width, height, n);\n    let [originX, originY] = caculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const center = [\n        (x1 + x2 + x3 + x4) / 4,\n        (y1 + y2 + y3 + y4) / 4,\n    ];\n    const pos1Rad = getRad(center, [x1, y1]);\n    const pos2Rad = getRad(center, [x2, y2]);\n    const direction =\n        (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) || (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n            ? 1 : -1;\n\n    return [\n        [left, top, right, bottom],\n        [originX, originY],\n        [[x1, y1], [x2, y2], [x3, y3], [x4, y4]],\n        direction,\n    ];\n}\nexport function getDistSize(vec: number[]) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1],\n    ]);\n}\nexport function getLineStyle(pos1: number[], pos2: number[], rad: number = getRad(pos1, pos2)) {\n    const width = getDiagonalSize(pos1, pos2);\n\n    return {\n        transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad)`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translate(${x}px, ${y}px) rotate(${rotation}rad)`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = window.getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\nexport function getSize(\n    target: SVGElement | HTMLElement,\n    style: CSSStyleDeclaration = window.getComputedStyle(target),\n    isOffset?: boolean,\n    isBoxSizing: boolean = isOffset || style.boxSizing === \"border-box\",\n) {\n    let width = (target as HTMLElement).offsetWidth;\n    let height = (target as HTMLElement).offsetHeight;\n    const hasOffset = !isUndefined(width);\n\n    if ((isOffset || isBoxSizing) && hasOffset) {\n        return [width, height];\n    }\n    width = target.clientWidth;\n    height = target.clientHeight;\n\n    if (!hasOffset && !width && !height) {\n        const bbox = (target as SVGGraphicsElement).getBBox();\n\n        return [bbox.width, bbox.height];\n    }\n    if (isOffset || isBoxSizing) {\n        const borderLeft = parseFloat(style.borderLeftWidth!) || 0;\n        const borderRight = parseFloat(style.borderRightWidth!) || 0;\n        const borderTop = parseFloat(style.borderTopWidth!) || 0;\n        const borderBottom = parseFloat(style.borderBottomWidth!) || 0;\n\n        return [\n            width + borderLeft + borderRight,\n            height + borderTop + borderBottom,\n        ];\n    } else {\n        const paddingLeft = parseFloat(style.paddingLeft!) || 0;\n        const paddingRight = parseFloat(style.paddingRight!) || 0;\n        const paddingTop = parseFloat(style.paddingTop!) || 0;\n        const paddingBottom = parseFloat(style.paddingBottom!) || 0;\n\n        return [\n            width - paddingLeft - paddingRight,\n            height - paddingTop - paddingBottom,\n        ];\n    }\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nexport function getTargetInfo(\n    moveableElement?: HTMLElement,\n    target?: HTMLElement | SVGElement,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    rootContainer?: HTMLElement | SVGElement | null,\n    state?: Partial<MoveableManagerState> | false | undefined,\n): Partial<MoveableManagerState> {\n    let left = 0;\n    let top = 0;\n    let right = 0;\n    let bottom = 0;\n    let origin = [0, 0];\n    let poses = [[0, 0], [0, 0], [0, 0], [0, 0]];\n    let rootMatrix = createIdentityMatrix3();\n    let offsetMatrix = createIdentityMatrix3();\n    let beforeMatrix = createIdentityMatrix3();\n    let matrix = createIdentityMatrix3();\n    let targetMatrix = createIdentityMatrix3();\n    let width = 0;\n    let height = 0;\n    let transformOrigin = [0, 0];\n    let direction: 1 | -1 = 1;\n    let beforeDirection: 1 | -1 = 1;\n    let is3d = false;\n    let targetTransform = \"\";\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let moveableClientRect = resetClientRect();\n    let rotation = 0;\n\n    const prevMatrix = state ? state.beforeMatrix : undefined;\n    const prevRootMatrix = state ? state.rootMatrix : undefined;\n    const prevN = state ? (state.is3d ? 4 : 3) : undefined;\n\n    if (target) {\n        if (state) {\n            width = state.width!;\n            height = state.height!;\n        } else {\n            const style = getComputedStyle(target);\n\n            width = (target as HTMLElement).offsetWidth;\n            height = (target as HTMLElement).offsetHeight;\n\n            if (isUndefined(width)) {\n                [width, height] = getSize(target, style, true);\n            }\n        }\n        [\n            rootMatrix,\n            beforeMatrix,\n            offsetMatrix,\n            matrix,\n            targetMatrix,\n            targetTransform, transformOrigin, is3d,\n        ] = caculateMatrixStack(\n            target, container!, rootContainer!,\n            prevMatrix, prevRootMatrix, prevN,\n        );\n\n        [\n            [left, top, right, bottom],\n            origin,\n            poses,\n            direction,\n        ] = caculateMoveablePosition(matrix, transformOrigin, width, height);\n\n        const n = is3d ? 4 : 3;\n        let beforePos = [0, 0];\n\n        [\n            beforePos, beforeOrigin, , beforeDirection,\n        ] = caculateMoveablePosition(offsetMatrix, plus(transformOrigin, getOrigin(targetMatrix, n)), width, height);\n\n        beforeOrigin = [\n            beforeOrigin[0] + beforePos[0] - left,\n            beforeOrigin[1] + beforePos[1] - top,\n        ];\n\n        targetClientRect = getClientRect(target);\n        containerClientRect = getClientRect(\n            getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body,\n            true,\n        );\n        if (moveableElement) {\n            moveableClientRect = getClientRect(moveableElement);\n        }\n        rotation = getRotationRad([poses[0], poses[1]], direction);\n    }\n\n    return {\n        rotation,\n        targetClientRect,\n        containerClientRect,\n        moveableClientRect,\n        beforeDirection,\n        direction,\n        target,\n        left,\n        top,\n        right,\n        bottom,\n        pos1: poses[0],\n        pos2: poses[1],\n        pos3: poses[2],\n        pos4: poses[3],\n        width,\n        height,\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        targetMatrix,\n        matrix,\n        targetTransform,\n        is3d,\n        beforeOrigin,\n        origin,\n        transformOrigin,\n    };\n}\nexport function resetClientRect(): MoveableClientRect {\n    return {\n        left: 0, right: 0,\n        top: 0, bottom: 0,\n        width: 0, height: 0,\n        clientLeft: 0, clientTop: 0,\n        clientWidth: 0, clientHeight: 0,\n        scrollWidth: 0, scrollHeight: 0,\n    };\n}\nexport function getClientRect(el: HTMLElement | SVGElement, isExtends?: boolean) {\n    const { left, width, top, bottom, right, height } = el.getBoundingClientRect();\n\n    const rect: MoveableClientRect = {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height,\n    };\n\n    if (isExtends) {\n        rect.clientLeft = el.clientLeft;\n        rect.clientTop = el.clientTop;\n        rect.clientWidth = el.clientWidth;\n        rect.clientHeight = el.clientHeight;\n        rect.scrollWidth = el.scrollWidth;\n        rect.scrollHeight = el.scrollHeight;\n    }\n    return rect;\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\nexport function roundSign(num: number) {\n    return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\nexport function throttle(num: number, unit: number) {\n    if (!unit) {\n        return num;\n    }\n    return Math.round(num / unit) * unit;\n}\nexport function throttleArray(nums: number[], unit: number) {\n    nums.forEach((_, i) => {\n        nums[i] = throttle(nums[i], unit);\n    });\n    return nums;\n}\n\nexport function unset(self: any, name: string) {\n    if (self[name]) {\n        self[name].unset();\n        self[name] = null;\n    }\n}\n\nexport function getOrientationDirection(pos: number[], pos1: number[], pos2: number[]) {\n    return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);\n}\nexport function isInside(pos: number[], pos1: number[], pos2: number[], pos3: number[], pos4: number[]) {\n    const k1 = getOrientationDirection(pos, pos1, pos2);\n    const k2 = getOrientationDirection(pos, pos2, pos3);\n    const k3 = getOrientationDirection(pos, pos3, pos1);\n\n    const k4 = getOrientationDirection(pos, pos2, pos3);\n    const k5 = getOrientationDirection(pos, pos3, pos4);\n    const k6 = getOrientationDirection(pos, pos4, pos2);\n    const signs1 = [k1, k2, k3];\n    const signs2 = [k4, k5, k6];\n\n    if (\n        signs1.every(sign => sign >= 0)\n        || signs1.every(sign => sign <= 0)\n        || signs2.every(sign => sign >= 0)\n        || signs2.every(sign => sign <= 0)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: Pick<T, Exclude<keyof T, \"target\" | \"clientX\" | \"clientY\" | \"inputEvent\" | \"datas\" | \"currentTarget\">>,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    return {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        datas: datas.datas,\n    } as any;\n}\n\nexport function triggerEvent<T extends IObject<any> = MoveableProps, U extends keyof T = string>(\n    moveable: any,\n    name: U & string,\n    params: T[U] extends ((e: infer P) => any) | undefined ? P : IObject<any>,\n    isManager?: boolean,\n): any {\n    if (isManager) {\n        MoveableManager.prototype.triggerEvent.call(moveable, name, params);\n    }\n    return moveable.triggerEvent(name, params);\n}\n\nexport function getComputedStyle(el: HTMLElement | SVGElement, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(\n    ables: Able[], methods: Array<keyof Able>,\n    triggerAblesSimultaneously?: boolean,\n) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (!triggerAblesSimultaneously && able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function getKeepRatioHeight(width: number, isWidth: boolean, ratio: number) {\n    return width * (isWidth ? ratio : 1 / ratio);\n}\nexport function getKeepRatioWidth(height: number, isWidth: boolean, ratio: number) {\n    return height * (isWidth ? 1 / ratio : ratio);\n}\n\nexport function equals(a1: any, a2: any) {\n    return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n    const length = values.length - 1;\n    for (let i = 0; i < length; ++i) {\n        const value = values[i];\n\n        if (!isUndefined(value)) {\n            return value;\n        }\n    }\n\n    return values[length];\n}\n\nexport function groupBy<T>(arr: T[], func: (el: T, index: number, arr: T[]) => any) {\n    const groups: T[][] = [];\n    const groupKeys: any[] = [];\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        const keyIndex = groupKeys.indexOf(groupKey);\n        const group = groups[keyIndex] || [];\n\n        if (keyIndex === -1) {\n            groupKeys.push(groupKey);\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function groupByMap<T>(arr: T[], func: (el: T, index: number, arr: T[]) => string | number) {\n    const groups: T[][] = [];\n    const groupKeys: IObject<T[]> = {};\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        let group = groupKeys[groupKey];\n\n        if (!group) {\n            group = [];\n            groupKeys[groupKey] = group;\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function flat<T>(arr: T[][]): T[] {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(cur);\n    }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n    return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(b) - Math.abs(a));\n\n    return args[0];\n}\nexport function minOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(a) - Math.abs(b));\n\n    return args[0];\n}\n\nexport function caculateInversePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(\n        invert(matrix, n),\n        convertPositionMatrix(pos, n),\n        n,\n    );\n}\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n    const {\n        is3d,\n        rootMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n    [\n        e.distX, e.distY,\n    ] = caculateInversePosition(rootMatrix, [e.distX, e.distY], n);\n\n    return e;\n}\n\nexport function caculatePadding(\n    matrix: number[], pos: number[],\n    transformOrigin: number[], origin: number[], n: number,\n) {\n    return minus(caculatePosition(matrix, plus(transformOrigin, pos),  n), origin);\n}\nexport function checkSize(targetSize: number[], compareSize: number[], isMax: boolean) {\n    return [\n        [compareSize[0], compareSize[0] * targetSize[1] / targetSize[0]],\n        [compareSize[1] * targetSize[0] / targetSize[1], compareSize[1]],\n    ].filter(size => size.every((value, i) => {\n        return isMax ? value <= compareSize[i] : value >= compareSize[i];\n    }))[0] || targetSize;\n}\nexport function caculateBoundSize(\n    size: number[], minSize: number[],\n    maxSize: number[], keepRatio?: boolean,\n) {\n    if (!keepRatio) {\n        return size.map((value, i) => Math.min(maxSize[i], Math.max(value, minSize[i])));\n    }\n    let [width, height] = size;\n    // width : height = minWidth : minHeight;\n    const [minWidth, minHeight] = checkSize(size, minSize, false);\n    const [maxWidth, maxHeight] = checkSize(size, maxSize, true);\n\n    if (width < minWidth || height < minHeight) {\n        width = minWidth;\n        height = minHeight;\n    } else if (width > maxWidth || height > maxHeight) {\n        width = maxWidth;\n        height = maxHeight;\n    }\n    return [width, height];\n}\n","import MoveableManager from \"../MoveableManager\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function triggerRenderStart(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent<any>(moveable, `onRender${eventAffix}Start`, params);\n}\nexport function triggerRender(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent<any>(moveable, `onRender${eventAffix}`, params);\n}\nexport function triggerRenderEnd(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.sPinch,\n        isDrag: e.isDrag,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent<any>(moveable, `onRender${eventAffix}End`, params);\n}\n","import MoveableManager from \"./MoveableManager\";\nimport { Able } from \"./types\";\nimport { IObject } from \"@daybrush/utils\";\nimport { triggerRenderStart, triggerRenderEnd, triggerRender } from \"./ables/triggerRender\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { convertDragDist } from \"./utils\";\nimport Dragger from \"@daybrush/drag\";\n\nexport function triggerAble<T extends IObject<any>>(\n    moveable: MoveableManager<any>,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: any,\n    isReqeust?: boolean,\n) {\n    const isStart = eventType === \"Start\";\n\n    if (isStart && eventAffix.indexOf(\"Control\") > -1 && !e.isRequest && moveable.areaElement === e.inputEvent.target) {\n        return false;\n    }\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType.indexOf(\"After\") > -1;\n\n    if (isStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    if (eventType === \"\" && !isAfter) {\n        convertDragDist(moveable.state, e);\n    }\n    const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Able[] = (moveable as any)[ableType];\n\n    if (!ables.length) {\n        return false;\n    }\n    const events = ables.filter((able: any) => able[eventName]);\n    const datas = e.datas;\n    const renderDatas = datas.render || (datas.render = {});\n    const renderEvent = { ...e, datas: renderDatas, originalDatas: datas };\n\n    const results = events.filter((able: any) => {\n        const condition = isStart && able[conditionName];\n        const ableName = able.name;\n        const nextDatas = datas[ableName] || (datas[ableName] = {});\n\n        if (!condition || condition(e, moveable)) {\n            return able[eventName](moveable, { ...e, datas: nextDatas, originalDatas: datas });\n        }\n        return false;\n    });\n    const isUpdate = results.length;\n\n    if (isStart) {\n        if (events.length && !isUpdate) {\n            moveable.state.dragger = null;\n\n            if ((moveable as MoveableGroup).moveables) {\n                (moveable as MoveableGroup).moveables.forEach(childeMoveable => {\n                    childeMoveable.state.dragger = null;\n                });\n            }\n            return false;\n        }\n        triggerRenderStart(moveable, isGroup, renderEvent);\n    } else if (isEnd) {\n        triggerRenderEnd(moveable, isGroup, renderEvent);\n    } else if (isUpdate) {\n        triggerRender(moveable, isGroup, renderEvent);\n    }\n    if (isEnd) {\n        moveable.state.dragger = null;\n    }\n    if (moveable.isUnmounted) {\n        return false;\n    }\n    if (!isStart && isUpdate) {\n        if (results.some(able => able.updateRect) && !isGroup) {\n            moveable.updateRect(eventType, false, false);\n        } else {\n            moveable.updateRect(eventType, true, false);\n        }\n    }\n    if (((!isStart && isUpdate) || (isEnd && !isUpdate)) && !isReqeust) {\n        moveable.forceUpdate();\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n}\n\nexport function getTargetAbleDragger<T>(\n    moveable: MoveableManager<T>,\n    moveableTarget: HTMLElement | SVGElement,\n    eventAffix: string,\n) {\n    const controlBox = moveable.controlBox.getElement();\n    const targets: Array<HTMLElement | SVGElement> = [];\n\n    targets.push(controlBox);\n\n    if (!moveable.props.dragArea) {\n        targets.push(moveableTarget);\n    }\n\n    const startFunc = (e: any) => {\n        const eventTarget = e.inputEvent.target;\n        const areaElement = moveable.areaElement;\n\n        return eventTarget === areaElement\n            || !moveable.isMoveableElement(eventTarget)\n            || eventTarget.className.indexOf(\"moveable-area\") > -1\n            || eventTarget.className.indexOf(\"moveable-padding\") > -1;\n    };\n\n    return getAbleDragger(moveable, targets, \"targetAbles\", eventAffix, {\n        dragstart: startFunc,\n        pinchstart: startFunc,\n    });\n}\nexport function getAbleDragger<T>(\n    moveable: MoveableManager<T>,\n    target: HTMLElement | SVGElement | Array<HTMLElement | SVGElement>,\n    ableType: string,\n    eventAffix: string,\n    conditionFunctions: IObject<any> = {},\n) {\n    const {\n        pinchOutside,\n        pinchThreshold,\n    } = moveable.props;\n    const options: IObject<any> = {\n        container: window,\n        pinchThreshold,\n        pinchOutside,\n    };\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            const eventName = `${eventOperation}${eventType.toLowerCase()}`;\n            options[eventName]\n                = (e: any) => {\n                    if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n                        return false;\n                    }\n                    return triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n                };\n        });\n    });\n\n    return new Dragger(target!, options);\n}\n","import * as React from \"react\";\nimport { MOVEABLE_CSS, PREFIX } from \"./consts\";\nimport {\n    prefix, getLineStyle,\n    getTargetInfo,\n    unset,\n    createIdentityMatrix3,\n    isInside,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n    resetClientRect,\n    throttle,\n    flat,\n    groupByMap,\n    caculatePadding,\n} from \"./utils\";\nimport styled from \"react-css-styled\";\nimport Dragger from \"@daybrush/drag\";\nimport { ref } from \"framework-utils\";\nimport { MoveableManagerProps, MoveableManagerState, Able, RectInfo, Requester, PaddingBox, HitRect } from \"./types\";\nimport { triggerAble, getTargetAbleDragger, getAbleDragger } from \"./getAbleDragger\";\nimport { getRad, plus } from \"@moveable/matrix\";\nimport { IObject } from \"@daybrush/utils\";\n\nconst ControlBoxElement = styled(\"div\", MOVEABLE_CSS);\n\nfunction renderLine(direction: string, pos1: number[], pos2: number[], index: number) {\n    const rad = getRad(pos1, pos2);\n    const rotation = direction ? (throttle(rad / Math.PI * 180, 15)) % 180 : -1;\n\n    return <div key={`line${index}`} className={prefix(\"line\", \"direction\", direction)}\n        data-rotation={rotation}\n        data-direction={direction} style={getLineStyle(pos1, pos2, rad)}></div>;\n}\nexport default class MoveableManager<T = {}, U = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState<U>> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        dragTarget: null,\n        container: null,\n        rootContainer: null,\n        origin: true,\n        edge: false,\n        parentMoveable: null,\n        parentPosition: null,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n        zoom: 1,\n        triggerAblesSimultaneously: false,\n        padding: {},\n        pinchOutside: true,\n    };\n    public state: MoveableManagerState<U> = {\n        container: null,\n        target: null,\n        beforeMatrix: createIdentityMatrix3(),\n        matrix: createIdentityMatrix3(),\n        targetMatrix: createIdentityMatrix3(),\n        offsetMatrix: createIdentityMatrix3(),\n        targetTransform: \"\",\n        is3d: false,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        transformOrigin: [0, 0],\n        direction: 1,\n        beforeDirection: 1,\n        beforeOrigin: [0, 0],\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n        targetClientRect: resetClientRect(),\n        containerClientRect: resetClientRect(),\n        moveableClientRect: resetClientRect(),\n        rotation: 0,\n    } as any;\n    public targetAbles: Able[] = [];\n    public controlAbles: Able[] = [];\n    public controlBox!: typeof ControlBoxElement extends new (...args: any[]) => infer K ? K : never;\n    public areaElement!: HTMLElement;\n    public targetDragger!: Dragger;\n    public controlDragger!: Dragger;\n    public isUnmounted = false;\n\n    public render() {\n        const props = this.props;\n        const state = this.state;\n        const { edge, parentPosition, className, target: propsTarget, zoom } = props;\n\n        this.checkUpdate();\n        this.updateRenderPoses();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const { left, top, target: stateTarget, direction, renderPoses } = state;\n        const groupTargets = (props as any).targets;\n        const isDisplay = ((groupTargets && groupTargets.length) || propsTarget) && stateTarget;\n\n        return (\n            <ControlBoxElement\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\")} ${className}`} style={{\n                    \"position\": \"absolute\",\n                    \"display\": isDisplay ? \"block\" : \"none\",\n                    \"transform\": `translate(${left - parentLeft}px, ${top - parentTop}px) translateZ(50px)`,\n                    \"--zoom\": zoom,\n                    \"--zoompx\": `${zoom}px`,\n                }}>\n                {this.renderAbles()}\n                {renderLine(edge ? \"n\" : \"\", renderPoses[0], renderPoses[1], 0)}\n                {renderLine(edge ? \"e\" : \"\", renderPoses[1], renderPoses[3], 1)}\n                {renderLine(edge ? \"w\" : \"\", renderPoses[0], renderPoses[2], 2)}\n                {renderLine(edge ? \"s\" : \"\", renderPoses[2], renderPoses[3], 3)}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container } = props;\n\n        this.updateEvent(props);\n        if (!container && !parentMoveable) {\n            this.updateRect(\"End\", false, true);\n        }\n    }\n    public componentDidUpdate(prevProps: MoveableManagerProps<T>) {\n        this.updateEvent(prevProps);\n    }\n    public componentWillUnmount() {\n        this.isUnmounted = true;\n        unset(this, \"targetDragger\");\n        unset(this, \"controlDragger\");\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, container } = this.props;\n\n        return container!\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    public isMoveableElement(target: HTMLElement | SVGElement) {\n        return target && ((target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1);\n    }\n    public dragStart(e: MouseEvent | TouchEvent) {\n        if (this.targetDragger) {\n            this.targetDragger.onDragStart(e);\n        }\n        return this;\n    }\n    public hitTest(el: Element | HitRect): number {\n        let rect: Required<HitRect>;\n\n        if (el instanceof Element) {\n            const clientRect = el.getBoundingClientRect();\n\n            rect = {\n                left: clientRect.left,\n                top: clientRect.top,\n                width: clientRect.width,\n                height: clientRect.height,\n            };\n        } else {\n            rect = { width: 0, height: 0, ...el };\n        }\n        const {\n            left: rectLeft,\n            top: rectTop,\n            width: rectWidth,\n            height: rectHeight,\n        } = this.state.targetClientRect;\n        const {\n            left,\n            top,\n            width,\n            height,\n        } = rect;\n        const right = left + width;\n        const bottom = top + height;\n        const rectRight = rectLeft + rectWidth;\n        const rectBottom = rectTop + rectHeight;\n        const testLeft = Math.max(rectLeft, left);\n        const testRight = Math.min(rectRight, right);\n        const testTop = Math.max(rectTop, top);\n        const testBottom = Math.min(rectBottom, bottom);\n\n        if (testRight < testLeft || testBottom < testTop) {\n            return 0;\n        }\n\n        const rectSize = (Math.min(rectRight, right) - Math.max(left, rectLeft))\n        * (Math.min(rectBottom, bottom) - Math.max(rectTop, top));\n\n        return Math.min(100, (testRight - testLeft) * (testBottom - testTop) / rectSize * 100);\n    }\n    public isInside(clientX: number, clientY: number) {\n        const { pos1, pos2, pos3, pos4, target, targetClientRect } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        const { left, top } = targetClientRect;\n        const pos = [clientX - left, clientY - top];\n\n        return isInside(pos, pos1, pos2, pos3, pos4);\n    }\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const props = this.props;\n        const parentMoveable = props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        const rootContainer = parentMoveable\n            ? parentMoveable.props.rootContainer\n            : props.rootContainer;\n        this.updateState(\n            getTargetInfo(this.controlBox && this.controlBox.getElement(),\n                target, container, container,\n                rootContainer || container, isTarget ? state : undefined),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    public updateEvent(prevProps: MoveableManagerProps<T>) {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const prevTarget = prevProps.dragTarget || prevProps.target;\n        const dragArea = props.dragArea;\n        const prevDragArea = prevProps.dragArea;\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isUnset = (!hasTargetAble && this.targetDragger)\n            || isTargetChanged\n            || prevDragArea !== dragArea;\n\n        if (isUnset) {\n            unset(this, \"targetDragger\");\n            this.updateState({ dragger: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlDragger\");\n        }\n\n        if (target && hasTargetAble && !this.targetDragger) {\n            this.targetDragger = getTargetAbleDragger(this, target!, \"\");\n        }\n        if (!this.controlDragger && hasControlAble) {\n            this.controlDragger = getAbleDragger(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n        if (isUnset) {\n            this.unsetAbles();\n        }\n    }\n    public isDragging() {\n        return (this.targetDragger ? this.targetDragger.isFlag() : false)\n        || (this.controlDragger ? this.controlDragger.isFlag() : false);\n    }\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        const statePos = [state.left, state.top];\n        const origin = plus(statePos, state.origin);\n        const beforeOrigin = plus(statePos, state.beforeOrigin);\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n            beforeOrigin,\n            origin,\n        };\n    }\n    public request(ableName: string, param: IObject<any> = {}, isInstant?: boolean): Requester {\n        const { ables, groupable } = this.props as any;\n        const requsetAble: Able = ables!.filter((able: Able) => able.name === ableName)[0];\n\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\n            return {\n                request() {\n                    return this;\n                },\n                requestEnd() {\n                    return this;\n                },\n            };\n        }\n        const self = this;\n        const ableRequester = requsetAble.request(this);\n\n        const ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n        const eventAffix = `${(groupable ? \"Group\" : \"\")}${ableRequester.isControl ? \"Control\" : \"\"}`;\n\n        const requester = {\n            request(ableParam: IObject<any>) {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"\", {\n                    ...ableRequester.request(ableParam),\n                    isRequest: true,\n                }, isInstant);\n                return this;\n            },\n            requestEnd() {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"End\", {\n                    ...ableRequester.requestEnd(),\n                    isRequest: true,\n                });\n                return this;\n            },\n        };\n\n        triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", {\n            ...ableRequester.requestStart(param),\n            isRequest: true,\n        }, isInstant);\n\n        return param.isInstant ? requester.request(param).requestEnd() : requester;\n    }\n    public updateRenderPoses() {\n        const state = this.state;\n        const props = this.props;\n        const {\n            beforeOrigin, transformOrigin,\n            matrix, is3d, pos1, pos2, pos3, pos4, left: stateLeft, top: stateTop } = state;\n        const {\n            left = 0,\n            top = 0,\n            bottom = 0,\n            right = 0,\n        } = (props.padding || {}) as PaddingBox;\n        const n = is3d ? 4 : 3;\n\n        const absoluteOrigin = (props as any).groupable ? beforeOrigin : plus(beforeOrigin, [stateLeft, stateTop]);\n        state.renderPoses = [\n            plus(pos1, caculatePadding(matrix, [-left, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos2, caculatePadding(matrix, [right, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos3, caculatePadding(matrix, [-left, bottom], transformOrigin, absoluteOrigin, n)),\n            plus(pos4, caculatePadding(matrix, [right, bottom], transformOrigin, absoluteOrigin, n)),\n        ];\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n\n        this.updateState({ target, container });\n\n        if (!parentMoveable && (container || this.controlBox)) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    protected unsetAbles() {\n        if (this.targetAbles.filter(able => {\n            if (able.unset) {\n                able.unset(this);\n                return true;\n            }\n            return false;\n        }).length) {\n            this.forceUpdate();\n        }\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const enabledAbles = ables!.filter(able => able && props[able.name]);\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            this.setState(nextState);\n        } else {\n            const state = this.state as any;\n\n            for (const name in nextState) {\n                state[name] = nextState[name];\n            }\n        }\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const enabledAbles = ables.filter(able => able && props[able.name]);\n        const Renderer = { createElement: React.createElement };\n\n        return groupByMap(flat<any>(\n            filterAbles(enabledAbles, [\"render\"], triggerAblesSimultaneously).map(({ render }) => {\n                return render!(this, Renderer) || [];\n            })).filter(el => el), ({ key }) => key).map(group => group[0]);\n    }\n}\n","import { Client } from \"@daybrush/drag\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { PinchableProps, Able, SnappableState, OnPinchStart, OnPinch, OnPinchEnd } from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { getRad } from \"@moveable/matrix\";\n\nfunction getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport default {\n    name: \"pinchable\",\n    updateRect: true,\n    props: {\n        pinchable: Boolean,\n        pinchOutside: Boolean,\n        pinchThreshold: Number,\n    },\n    pinchStart(\n        moveable: MoveableManager<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, touches, targets } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        const parentRotate = getRotatiion(touches);\n\n        pinchAbles.forEach(able => {\n            datas[able.name + \"Datas\"] = {};\n\n            if (!able[controlEventName]) {\n                return;\n            }\n            const ableEvent: any = {\n                ...e,\n                datas: datas[able.name + \"Datas\"],\n                parentRotate,\n                isPinch: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, scale: pinchScale, distance, touches, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentRotate = getRotatiion(touches);\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                parentDistance,\n                parentRotate,\n                isPinch: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, isPinch, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                isDrag: isPinch,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                isPinch: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroup, e: any) {\n        return this.pinchStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroup, e: any) {\n        return this.pinch(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroup, e: any) {\n        return this.pinchEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n","import { MoveableManagerState, OnCustomDrag } from \"./types\";\nimport { convertDragDist } from \"./utils\";\n\nexport function setCustomDrag(\n    state: MoveableManagerState<any>,\n    delta: number[],\n    inputEvent: any,\n    isPinch: boolean,\n    isConvert: boolean,\n) {\n    const result = state.dragger!.move(delta, inputEvent);\n    const datas = result.originalDatas || result.datas;\n    const draggableDatas = datas.draggable || (datas.draggable = {});\n\n    return {\n        ...(isConvert ? convertDragDist(state, result) : result),\n        isDrag: true,\n        isPinch: !!isPinch,\n        parentEvent: true,\n        datas: draggableDatas,\n    };\n}\n\nexport default class CustomDragger {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas: any = {\n        draggable: {},\n    };\n\n    public dragStart(client: number[], inputEvent: any) {\n        this.isDrag = false;\n        this.isFlag = false;\n        this.datas = {\n            draggable: {},\n        };\n        return {\n            ...this.move(client, inputEvent),\n            type: \"dragstart\",\n        };\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n            this.isDrag = true;\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            type: \"drag\",\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas.draggable,\n            originalDatas: this.datas,\n            parentEvent: true,\n            parentDragger: this,\n        };\n    }\n}\n","import MoveableGroup from \"./MoveableGroup\";\nimport { Able } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { IObject, isFunction } from \"@daybrush/utils\";\nimport CustomDragger, { setCustomDrag } from \"./CustomDragger\";\nexport function triggerChildDragger(\n    moveable: MoveableGroup,\n    able: Able,\n    type: string,\n    delta: number[],\n    e: any,\n    isConvert: boolean,\n) {\n    const isStart = !!type.match(/Start$/g);\n    const isEnd = !!type.match(/End$/g);\n    const inputEvent = e.inputEvent;\n    const isPinch = e.isPinch;\n    const datas = e.datas;\n    const childs = moveable.moveables.map((child, i) => {\n        let childEvent = {};\n\n        if (isStart) {\n            childEvent = new CustomDragger().dragStart(delta, inputEvent);\n        } else {\n            if (!child.state.dragger) {\n                child.state.dragger = datas.childDraggers[i];\n            }\n            childEvent = setCustomDrag(child.state, delta, inputEvent, isPinch, isConvert);\n        }\n        const result = (able as any)[type]!(child,  { ...childEvent, parentFlag: true });\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n    if (isStart) {\n        datas.childDraggers = moveable.moveables.map(child => child.state.dragger);\n    }\n    return childs;\n}\nexport function triggerChildAble<T extends Able>(\n    moveable: MoveableGroup,\n    able: T,\n    type: keyof T & string,\n    datas: IObject<any>,\n    eachEvent: ((movebale: MoveableManager, datas: IObject<any>) => any) | IObject<any>,\n    callback?: (moveable: MoveableManager<any>, datas: IObject<any>, result: any, index: number) => any,\n) {\n    const name = able.name!;\n    const ableDatas = datas[name] || (datas[name] = []);\n    const isEnd = !!type.match(/End$/g);\n    const childs = moveable.moveables.map((child, i) => {\n        const childDatas = ableDatas[i] || (ableDatas[i] = {});\n\n        const childEvent = isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;\n        const result = (able as any)[type]!(child,  { ...childEvent, datas: childDatas, parentFlag: true });\n\n        result && callback && callback(child, childDatas, result, i);\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n\n    return childs;\n}\n","import {\n    invert, caculate, minus, plus,\n    convertPositionMatrix, average,\n    createScaleMatrix, multiply,\n} from \"@moveable/matrix\";\nimport MoveableManager from \"./MoveableManager\";\nimport { caculatePoses, getAbsoluteMatrix, getAbsolutePosesByState } from \"./utils\";\nimport { splitUnit } from \"@daybrush/utils\";\nimport { MoveableManagerState, GroupableProps, ResizableProps } from \"./types\";\n\nexport function setDragStart(moveable: MoveableManager<any>, { datas }: any) {\n    const {\n        matrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = matrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(matrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = caculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function getInverseDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        beforeMatrix,\n        matrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? beforeMatrix : matrix,\n            plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n            n,\n        ),\n        absoluteOrigin,\n    );\n}\nexport function caculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    const nextPoses = getPosesByDirection(poses, direction);\n\n    return [\n        average(...nextPoses.map(pos => pos[0])),\n        average(...nextPoses.map(pos => pos[1])),\n    ];\n}\nexport function getPosByReverseDirection(\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n    [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n    [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n    */\n\n    return getPosByDirection([pos4, pos3, pos2, pos1], direction);\n}\nfunction getStartPos(poses: number[][], direction: number[]) {\n    const [\n        startPos1,\n        startPos2,\n        startPos3,\n        startPos4,\n    ] = poses;\n    return getPosByReverseDirection([startPos1, startPos2, startPos3, startPos4], direction);\n}\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    direction: number[],\n) {\n    const poses = caculatePoses(matrix, width, height, n);\n    const pos = getPosByReverseDirection(poses, direction);\n    const distX = startPos[0] - pos[0];\n    const distY = startPos[1] - pos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\nexport function getScaleDist(\n    moveable: MoveableManager<any>,\n    scale: number[],\n    direction: number[],\n    fixedPosition: number[],\n) {\n    const state = moveable.state;\n    const {\n        is3d,\n        left,\n        top,\n        width,\n        height,\n    } = state;\n\n    const n = is3d ? 4 : 3;\n    const groupable = moveable.props.groupable;\n    const nextMatrix = scaleMatrix(moveable.state, scale);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\n\nexport function getResizeDist(\n    moveable: MoveableManager<GroupableProps>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    transformOrigin: string[],\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const {\n        transformOrigin: prevOrigin,\n        targetMatrix,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = moveable.state;\n\n    const n = is3d ? 4 : 3;\n    const nextOrigin = caculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getStartDirection(\n    moveable: MoveableManager<ResizableProps>,\n    direction: number[],\n) {\n    if (!direction[0] && !direction[1]) {\n        return [0, 0];\n    }\n    const {\n        baseDirection = [-1, -1],\n    } = moveable.props;\n    return [\n        direction[0] ? direction[0] : baseDirection[0] * -1,\n        direction[1] ? direction[1] : baseDirection[1] * -1,\n    ];\n}\nexport function getAbsoluteFixedPosition(\n    moveable: MoveableManager<ResizableProps>,\n    direction: number[],\n) {\n    return getStartPos(getAbsolutePosesByState(moveable.state), direction);\n}\n","import { prefix } from \"../utils\";\nimport { hasClass } from \"@daybrush/utils\";\n\nexport function directionCondition(e: any) {\n    if (e.isRequest) {\n        return e.parentDirection!!;\n    }\n    return hasClass(e.inputEvent.target, prefix(\"direction\"));\n}\n","import {\n    SnapInfo, SnappableProps, SnappableState,\n    Guideline, ResizableProps, ScalableProps, SnapOffsetInfo\n} from \"../../types\";\nimport MoveableManager from \"../../MoveableManager\";\nimport { selectValue, throttle, getAbsolutePosesByState, getRect, groupBy } from \"../../utils\";\nimport { getPosByDirection, getPosesByDirection } from \"../../DraggerUtils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"@moveable/matrix\";\n\nexport function getGapGuidelines(\n    guidelines: Guideline[],\n    type: \"vertical\" | \"horizontal\",\n    snapThreshold: number,\n    index: number,\n    [start, end]: number[],\n    [otherStart, otherEnd]: number[],\n) {\n    const totalGuidelines: Guideline[] = [];\n    const otherIndex = index ? 0 : 1;\n    const otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n\n    const elementGuidelines\n        = groupBy(guidelines.filter(({ type: guidelineType }) => guidelineType === type), ({ element }) => element)\n        .map(group => group[0])\n        .filter(({ pos, sizes }) => pos[otherIndex] <= otherEnd && otherStart <= pos[otherIndex] + sizes![otherIndex]);\n\n    elementGuidelines.forEach(guideline1 => {\n        const elementStart = guideline1.pos[index];\n        const elementEnd = elementStart + guideline1.sizes![index];\n\n        elementGuidelines.forEach(({\n            pos: guideline2Pos,\n            sizes: guideline2Sizes,\n            element: guideline2Element,\n        }) => {\n            const targetStart = guideline2Pos[index];\n            const targetEnd = targetStart + guideline2Sizes![index];\n            let pos = 0;\n            let gap = 0;\n            let canSnap = true;\n\n            if (elementEnd <= targetStart) {\n                // gap -\n                gap = elementEnd - targetStart;\n                pos = targetEnd - gap;\n\n                if (start < pos - snapThreshold) {\n                    canSnap = false;\n                }\n                // element target moveable\n            } else if (targetEnd <= elementStart) {\n                // gap +\n                gap = elementStart - targetEnd;\n                pos = targetStart - gap;\n\n                if (end > pos + snapThreshold) {\n                    canSnap = false;\n                }\n                // moveable target element\n            } else {\n                return;\n            }\n            if (canSnap) {\n                totalGuidelines.push({\n                    pos: otherType === \"vertical\" ? [pos, guideline2Pos[1]] : [guideline2Pos[0], pos],\n                    element: guideline2Element,\n                    sizes: guideline2Sizes,\n                    size: 0,\n                    type: otherType,\n                    gap,\n                    gapGuidelines: elementGuidelines,\n                });\n            }\n            if (elementEnd <= start && end <= targetStart) {\n                // elementEnd   moveable   target\n                const centerPos = ((targetStart + elementEnd) - (end - start)) / 2;\n\n                if (throttle(start - (centerPos - snapThreshold), 0.1) >= 0) {\n                    totalGuidelines.push({\n                        pos: otherType === \"vertical\" ? [centerPos, guideline2Pos[1]] : [guideline2Pos[0], centerPos],\n                        element: guideline2Element,\n                        sizes: guideline2Sizes,\n                        size: 0,\n                        type: otherType,\n                        gap: elementEnd - start,\n                        gapGuidelines: elementGuidelines,\n                    });\n                }\n            }\n        });\n    });\n    return totalGuidelines;\n}\nexport function getTotalGuidelines(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n) {\n    const {\n        guidelines,\n        containerClientRect: {\n            scrollHeight: containerHeight,\n            scrollWidth: containerWidth,\n        },\n    } = moveable.state;\n    const props = moveable.props;\n    const {\n        snapHorizontal = true,\n        snapVertical = true,\n        snapGap = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n        snapThreshold = 5,\n    } = props;\n    const totalGuidelines: Guideline[] = [...guidelines];\n\n    if (snapGap) {\n        const { top, left, bottom, right } = getRect(getAbsolutePosesByState(moveable.state));\n        const elementGuidelines = (guidelines as Guideline[]).filter(({ element }) => element);\n\n        totalGuidelines.push(...getGapGuidelines(\n            elementGuidelines,\n            \"horizontal\",\n            snapThreshold,\n            0,\n            [left, right],\n            [top, bottom],\n        ), ...getGapGuidelines(\n            elementGuidelines,\n            \"vertical\",\n            snapThreshold,\n            1,\n            [top, bottom],\n            [left, right],\n        ));\n    }\n\n    if (snapHorizontal && horizontalGuidelines) {\n        horizontalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"horizontal\", pos: [0, throttle(pos, 0.1)], size: containerWidth! });\n        });\n    }\n    if (snapVertical && verticalGuidelines) {\n        verticalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"vertical\", pos: [throttle(pos, 0.1), 0], size: containerHeight! });\n        });\n    }\n\n    return totalGuidelines;\n}\nexport function checkSnapPoses(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    snapCenter?: boolean,\n    customSnapThreshold?: number,\n) {\n    const totalGuidelines = getTotalGuidelines(moveable);\n    const props = moveable.props;\n    const {\n        snapElement = true,\n    } = props;\n    const snapThreshold = selectValue<number>(customSnapThreshold, props.snapThreshold, 5);\n\n    return {\n        vertical: checkSnap(\n            totalGuidelines,\n            \"vertical\", posesX, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n        horizontal: checkSnap(\n            totalGuidelines,\n            \"horizontal\", posesY, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n    };\n}\n\nexport function checkSnapKeepRatio(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n): {\n    vertical: SnapOffsetInfo,\n    horizontal: SnapOffsetInfo,\n} {\n    const [endX, endY] = endPos;\n    const [startX, startY] = startPos;\n    let [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    dx = Math.abs(dx) <= TINY_NUM ? 0 : dx;\n    dy = Math.abs(dy) <= TINY_NUM ? 0 : dy;\n\n    const verticalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    }\n    const {\n        vertical: verticalSnapInfo,\n        horizontal: horizontalSnapInfo,\n    } = checkSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []);\n\n    verticalSnapInfo.posInfos.filter(({ pos }) => {\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(({ pos }) => {\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n    const {\n        isSnap: isVerticalSnap,\n        guideline: verticalGuideline,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n    const {\n        isSnap: isHorizontalSnap,\n        guideline: horizontalGuideline,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n    const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline!.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isSnap = false;\n\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\n\nexport function checkSnaps(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    rect: {\n        left?: number,\n        top?: number,\n        bottom?: number,\n        right?: number,\n        center?: number,\n        middle?: number,\n    },\n    isCenter: boolean,\n    customSnapThreshold?: number,\n) {\n    const snapCenter = moveable.props.snapCenter;\n    const isSnapCenter = snapCenter! && isCenter;\n\n    let verticalNames: Array<\"left\" | \"center\" | \"right\"> = [\"left\", \"right\"];\n    let horizontalNames: Array<\"top\" | \"middle\" | \"bottom\"> = [\"top\", \"bottom\"];\n\n    if (isSnapCenter) {\n        verticalNames.push(\"center\");\n        horizontalNames.push(\"middle\");\n    }\n    verticalNames = verticalNames.filter(name => name in rect);\n    horizontalNames = horizontalNames.filter(name => name in rect);\n\n    return checkSnapPoses(\n        moveable,\n        verticalNames.map(name => rect[name]!),\n        horizontalNames.map(name => rect[name]!),\n        isSnapCenter,\n        customSnapThreshold,\n    );\n}\n\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\n\nfunction checkSnap(\n    guidelines: Guideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    snapThreshold: number,\n    snapCenter: boolean,\n    snapElement: boolean,\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map(targetPos => {\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: Math.abs(offset),\n                guideline,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type, center, element } = guideline;\n            if (\n                (!snapElement && element)\n                || (!snapCenter && center)\n                || type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n        return {\n            pos: targetPos,\n            guidelineInfos,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    return {\n        isSnap: snapPosInfos.length > 0,\n        posInfos: snapPosInfos,\n    };\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManager<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    poses: number[][],\n    snapDirection: number[],\n) {\n    let nextPoses = [];\n    if (snapDirection[0] && snapDirection[1]) {\n        nextPoses = [\n            snapDirection,\n            [-snapDirection[0], snapDirection[1]],\n            [snapDirection[0], -snapDirection[1]],\n        ].map(direction => getPosByDirection(poses, direction));\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            nextPoses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n    } else {\n        if (moveable.props.keepRatio) {\n            nextPoses = [\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1],\n                snapDirection,\n            ].map(dir => getPosByDirection(poses, dir));\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n    }\n    return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n}\n\nexport function getNearOffsetInfo<T extends { offset: number[], isBound: boolean, isSnap: boolean, sign: number[] }>(\n    offsets: T[],\n    index: number,\n) {\n    return offsets.slice().sort((a, b) => {\n        const aSign = a.sign[index];\n        const bSign = b.sign[index];\n        const aOffset = a.offset[index];\n        const bOffset = b.offset[index];\n        const aDist = Math.abs(aOffset);\n        const bDist = Math.abs(bOffset);\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        } else if (a.isBound && b.isBound) {\n            return bDist - aDist;\n        } else if (a.isBound) {\n            return -1;\n        } else if (b.isBound) {\n            return 1;\n        } else if (a.isSnap && b.isSnap) {\n            return aDist - bDist;\n        } else if (a.isSnap) {\n            return -1;\n        } else if (b.isSnap) {\n            return 1;\n        } else if (aDist < TINY_NUM) {\n            return 1;\n        } else if (bDist < TINY_NUM) {\n            return -1;\n        }\n        return aDist - bDist;\n    })[0];\n}\n","import { maxOffset, getDistSize, throttle } from \"../../utils\";\nimport { average, rotate, getRad } from \"@moveable/matrix\";\nimport MoveableManager from \"../../MoveableManager\";\nimport { SnappableProps, DraggableProps, RotatableProps } from \"../../types\";\nimport { getDragDist, getPosByDirection, getInverseDragDist } from \"../../DraggerUtils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n    // l    o     => true\n    // o    l    => false\n    const cx = average(line[0][0], line[1][0]);\n    const cy = average(line[0][1], line[1][1]);\n\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1],\n    };\n}\nfunction hitTestLine(\n    dot: number[],\n    [pos1, pos2]: number[][],\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    let test1: number;\n    let test2: number;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        const a = dy / dx;\n\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots: number[][], line: number[][], error: number = TINY_NUM) {\n    const centerSign = hitTestLine(dots[0], line) <= 0;\n\n    return dots.slice(1).every(dot => {\n        const value = hitTestLine(dot, line);\n        const sign = value <= 0;\n        return sign === centerSign || Math.abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(\n    pos: number,\n    start: number,\n    end: number,\n    isStart: boolean,\n    threshold: number = 0,\n) {\n    if (\n        (isStart && start - threshold <= pos)\n        || (!isStart && pos <= end + threshold)\n    ) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos,\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\n\nfunction checkInnerBound(\n    moveable: MoveableManager<SnappableProps>,\n    line: number[][],\n    center: number[],\n) {\n    const bounds = moveable.props.innerBounds;\n\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    const { left, top, width, height } = bounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n    const {\n        horizontal: isHorizontalStart,\n        vertical: isVerticalStart,\n    } = isStartLine(center, line);\n\n    if (isSameStartLine([\n        center,\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n    ], line)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n\n    // test vertical\n    const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);\n    const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart);\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);\n    const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);\n\n    const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    const horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n\n    let offset = [0, 0];\n    let isBound = false;\n    let isAllBound = false;\n\n    if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n        offset = [verticalOffset, 0];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [0, horizontalOffset];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound,\n        isVerticalBound,\n        isHorizontalBound,\n        isBound,\n        offset,\n    };\n}\n\nfunction checkLineBoundCollision(\n    line: number[][],\n    boundLine: number[][],\n    isStart: boolean,\n    threshold?: number,\n) {\n    const dot1 = line[0];\n    const dot2 = line[1];\n    const boundDot1 = boundLine[0];\n    const boundDot2 = boundLine[1];\n    const dy1 = dot2[1] - dot1[1];\n    const dx1 = dot2[0] - dot1[0];\n\n    const dy2 = boundDot2[1] - boundDot1[1];\n    const dx2 = boundDot2[0] - boundDot1[0];\n\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        if (dx1) {\n            const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        }\n    } else if (!dy2) {\n        // horizontal\n\n        if (dy1) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            const a = dy1 / dx1;\n            const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\nexport function getInnerBoundInfo(\n    moveable: MoveableManager<SnappableProps>,\n    lines: number[][][],\n    center: number[],\n    datas: any,\n) {\n    return lines.map(([multiple, pos1, pos2]) => {\n        const {\n            isBound,\n            offset,\n            isVerticalBound,\n            isHorizontalBound,\n        } = checkInnerBound(moveable, [pos1, pos2], center);\n\n        const sizeOffset = getDragDist({\n            datas,\n            distX: offset[0],\n            distY: offset[1],\n        }).map((size, i) => size * (multiple[i] ?  2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound,\n            isVerticalBound,\n            isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset,\n        };\n    });\n}\n\nexport function getInnerBoundDragInfo(\n    moveable: MoveableManager<SnappableProps & DraggableProps, any>,\n    poses: number[][],\n    datas: any,\n) {\n    const lines = getCheckSnapLines(poses, [0, 0], false).map(([sign, pos1, pos2]) => {\n        return [\n            sign.map(dir => Math.abs(dir) * 2),\n            pos1,\n            pos2,\n        ];\n    });\n    const innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);\n    const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    let verticalOffset = 0;\n    let horizontalOffset = 0;\n    const isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    const isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n    if (isVerticalBound || isHorizontalBound) {\n        [verticalOffset, horizontalOffset] = getInverseDragDist({\n            datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1],\n        });\n    }\n\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset,\n        },\n    };\n}\nexport function getCheckSnapLineDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const lineDirections: number[][][] = [];\n    const x = direction[0];\n    const y = direction[1];\n    if (x && y) {\n        lineDirections.push(\n            [[0, y * 2], direction, [-x, y]],\n            [[x * 2, 0], direction, [x, -y]],\n        );\n    } else if (x) {\n        // vertcal\n        lineDirections.push(\n            [[x * 2, 0], [x, 1], [x, -1]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[0, -1], [x, -1], [-x, -1]],\n                [[0, 1], [x, 1], [-x, 1]],\n            );\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push(\n            [[0, y * 2], [1, y], [-1, y]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[-1, 0], [-1, y], [-1, -y]],\n                [[1, 0], [1, y], [1, -y]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push(\n            [[-1, 0], [-1, -1], [-1, 1]],\n            [[1, 0], [1, -1], [1, 1]],\n            [[0, -1], [-1, -1], [1, -1]],\n            [[0, 1], [-1, 1], [1, 1]],\n        );\n    }\n\n    return lineDirections;\n}\nexport function getCheckSnapLines(\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n) {\n    return getCheckSnapLineDirections(direction, keepRatio).map(([sign, dir1, dir2]) => {\n        return [\n            sign,\n            getPosByDirection(poses, dir1),\n            getPosByDirection(poses, dir2),\n        ];\n    });\n}\n\nfunction isBoundRotate(\n    relativePoses: number[][],\n    boundDots: number[][],\n    center: number[],\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n    const dots = [\n        center,\n        ...boundDots,\n    ];\n    return [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].some((line, i) => !isSameStartLine(dots, line));\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return Math.abs(pos1[0]);\n    }\n    if (!dy) {\n        return Math.abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n\n    const a = dy / dx;\n\n    return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return [pos1[0], 0];\n    }\n    if (!dy) {\n        return [0, pos1[1]];\n    }\n    const a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    const b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n\n    return [\n        -b / (a + 1 / a),\n        b / ((a * a) + 1),\n    ];\n}\nexport function checkRotateInnerBounds(\n    moveable: MoveableManager<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.innerBounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left,\n        top,\n        width,\n        height,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = left + width - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = top + height - origin[1];\n    const dots = [\n        [relativeLeft, relativeTop],\n        [relativeRight, relativeTop],\n        [relativeLeft, relativeBottom],\n        [relativeRight, relativeBottom],\n    ];\n    const center = getPosByDirection(nextPoses, [0, 0]);\n\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    const dotInfos = dots.map(dot => [\n        getDistSize(dot),\n        getRad([0, 0], dot),\n    ]);\n    [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].forEach(line => {\n        const lineRad = getRad([0, 0], solveReverseLine(line));\n        const lineDist = getDistPointLine(line);\n\n        result.push(...dotInfos\n            .filter(([dotDist]) => {\n                return dotDist && lineDist <= dotDist;\n            })\n            .map(([dotDist, dotRad]) => {\n                const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n                const nextRad1 = dotRad + distRad;\n                const nextRad2 = dotRad - distRad;\n\n                return [\n                    rad + nextRad1 - lineRad,\n                    rad + nextRad2 - lineRad,\n                ];\n            })\n            .reduce<number[]>((prev, cur) => {\n                prev.push(...cur);\n                return prev;\n            }, [])\n            .filter(nextRad => !isBoundRotate(prevPoses, dots, center, nextRad))\n            .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n    });\n    return result;\n}\n\nexport function checkInnerBoundPoses(\n    moveable: MoveableManager<SnappableProps>,\n) {\n    const innerBounds = moveable.props.innerBounds;\n\n    if (!innerBounds) {\n        return {\n            vertical: [],\n            horizontal: [],\n        };\n    }\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = moveable.getRect();\n    const poses = [pos1, pos2, pos3, pos4];\n    const center = getPosByDirection(poses, [0, 0]);\n    const { left, top, width, height } = innerBounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n\n    const lines = [\n        [pos1, pos2],\n        [pos2, pos4],\n        [pos4, pos3],\n        [pos3, pos1],\n    ];\n\n    const horizontalPoses: number[] = [];\n    const verticalPoses: number[] = [];\n\n    const boundMap = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false,\n    };\n\n    lines.forEach(line => {\n        const {\n            horizontal: isHorizontalStart,\n            vertical: isVerticalStart,\n        } = isStartLine(center, line);\n\n        // test vertical\n        const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1);\n        const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1);\n\n        // test horizontal\n        const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1);\n        const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1);\n\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n\n    return {\n        horizontal: horizontalPoses,\n        vertical: verticalPoses,\n    };\n}\n","import MoveableManager from \"../../MoveableManager\";\nimport { BoundInfo, SnappableProps, BoundType, RotatableProps } from \"../../types\";\nimport { rotate, getRad, minus } from \"@moveable/matrix\";\nimport { getDistSize, throttle } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n    moveable: MoveableManager<SnappableProps>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n) {\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = moveable.props.bounds || {};\n    const bounds = { left, top, right, bottom };\n\n    return {\n        vertical: checkBound(bounds, verticalPoses, true),\n        horizontal: checkBound(bounds, horizontalPoses, false),\n    };\n}\n\nexport function checkBoundKeepRatio(\n    moveable: MoveableManager<SnappableProps>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = moveable.props.bounds || {};\n\n    const [endX, endY] = endPos;\n    let [dx, dy] = minus(endPos, startPos);\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isBound = false;\n\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        }\n        if (isBound) {\n            if (y < top || y > bottom) {\n                isBound = false;\n            }\n        }\n        if (!isBound) {\n            if (isBottom && bottom <= endY) {\n                y = bottom;\n                x = (y - b) / a;\n                isBound = true;\n            } else if (!isBottom &&  endY <= top) {\n                y = top;\n                x = (y - b) / a;\n                isBound = true;\n            }\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\nfunction checkBound(\n    bounds: Required<BoundType>,\n    poses: number[],\n    isVertical: boolean,\n): BoundInfo {\n    // 0   [100 - 200]  300\n    const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n    // 450\n    const minPos = Math.min(...poses);\n    const maxPos = Math.max(...poses);\n\n    if (startBoundPos + 1 > minPos) {\n        return {\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos,\n        };\n    }\n    if (endBoundPos - 1 < maxPos) {\n        return {\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos,\n        };\n    }\n\n    return {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n}\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n\n    return nextPoses.some(pos => {\n        return (pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1)\n            || (pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1)\n            || (pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1)\n            || (pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n    moveable: MoveableManager<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.bounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    [\n        [relativeLeft, 0],\n        [relativeRight, 0],\n        [relativeTop, 1],\n        [relativeBottom, 1],\n    ].forEach(([boundPos, index], i) => {\n        nextPoses.forEach(nextPos => {\n            const relativeRad1 = getRad([0, 0], nextPos);\n\n            result.push(...boundRotate(nextPos, boundPos, index)\n                .map(relativeRad2 => rad + relativeRad2 - relativeRad1)\n                .filter(nextRad => !isBoundRotate(prevPoses, boundRect, nextRad))\n                .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n        });\n    });\n\n    return result;\n}\n","import MoveableManager from \"../MoveableManager\";\nimport {\n    Renderer,\n    SnappableProps,\n    SnappableState, Guideline,\n    SnapInfo, BoundInfo,\n    ScalableProps, SnapPosInfo, RotatableProps,\n    RectInfo, DraggableProps, SnapOffsetInfo, GapGuideline, SnappableOptions, MoveableClientRect,\n} from \"../types\";\nimport {\n    prefix, caculatePoses, getRect,\n    getAbsolutePosesByState, getAbsolutePoses, throttle, roundSign,\n    getDistSize, groupBy, flat, maxOffset, minOffset, triggerEvent, caculateInversePosition, caculatePosition,\n} from \"../utils\";\nimport { IObject, find } from \"@daybrush/utils\";\nimport {\n    getPosByReverseDirection,\n    getDragDist, scaleMatrix, getPosByDirection,\n} from \"../DraggerUtils\";\nimport { minus, rotate, plus, getRad } from \"@moveable/matrix\";\nimport {\n    dragControlCondition as rotatableDragControlCondtion,\n} from \"./Rotatable\";\nimport { TINY_NUM } from \"../consts\";\nimport { directionCondition } from \"./utils\";\nimport {\n    getInnerBoundInfo, getCheckSnapLines,\n    getInnerBoundDragInfo, checkRotateInnerBounds, checkInnerBoundPoses,\n} from \"./snappable/innerBounds\";\nimport { checkBoundPoses, checkRotateBounds, checkBoundKeepRatio } from \"./snappable/bounds\";\nimport {\n    checkSnaps, getSnapInfosByDirection,\n    checkSnapPoses, getNearestSnapGuidelineInfo,\n    getNearOffsetInfo,\n    checkSnapKeepRatio,\n} from \"./snappable/snap\";\n\nexport function caculateContainerPos(\n    rootMatrix: number[],\n    containerRect: MoveableClientRect,\n    n: number,\n) {\n    const clientPos = caculatePosition(\n        rootMatrix, [containerRect.clientLeft!, containerRect.clientTop!], n);\n\n    return [\n        containerRect.left + clientPos[0],\n        containerRect.top + clientPos[1],\n    ];\n}\nexport function snapStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n    const state = moveable.state;\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n\n    const {\n        horizontalGuidelines = [],\n        verticalGuidelines = [],\n        elementGuidelines = [],\n        bounds,\n        snapCenter,\n    } = moveable.props;\n\n    if (!bounds && !horizontalGuidelines.length && !verticalGuidelines.length && !elementGuidelines.length) {\n        return;\n    }\n\n    const {\n        containerClientRect,\n        targetClientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const [containerLeft, containerTop] = caculateContainerPos(rootMatrix, containerClientRect, n);\n    const poses = getAbsolutePosesByState(state);\n    const targetLeft = Math.min(...poses.map(pos => pos[0]));\n    const targetTop = Math.min(...poses.map(pos => pos[1]));\n    const [distLeft, distTop] = minus([targetLeft, targetTop], caculateInversePosition(rootMatrix, [\n        clientLeft - containerLeft,\n        clientTop - containerTop,\n    ], n)).map(pos => roundSign(pos));\n\n    const guidelines: Guideline[] = [];\n\n    elementGuidelines!.forEach(el => {\n        const rect = el.getBoundingClientRect();\n        const left = rect.left - containerLeft;\n        const top = rect.top - containerTop;\n        const bottom = top + rect.height;\n        const right = left + rect.width;\n        const [elementLeft, elementTop] = caculateInversePosition(rootMatrix, [left, top], n);\n        const [elementRight, elementBottom] = caculateInversePosition(rootMatrix, [right, bottom], n);\n        const width = elementRight - elementLeft;\n        const height = elementBottom - elementTop;\n        const sizes = [width, height];\n\n        guidelines.push({\n            type: \"vertical\", element: el, pos: [\n                throttle(elementLeft + distLeft, 0.1),\n                elementTop,\n            ], size: height,\n            sizes,\n        });\n        guidelines.push({\n            type: \"vertical\", element: el, pos: [\n                throttle(elementRight + distLeft, 0.1),\n                elementTop,\n            ], size: height,\n            sizes,\n        });\n        guidelines.push({\n            type: \"horizontal\", element: el, pos: [\n                elementLeft,\n                throttle(elementTop + distTop, 0.1),\n            ], size: width,\n            sizes,\n        });\n        guidelines.push({\n            type: \"horizontal\", element: el, pos: [\n                elementLeft,\n                throttle(elementBottom + distTop, 0.1),\n            ], size: width,\n            sizes,\n        });\n\n        if (snapCenter) {\n            guidelines.push({\n                type: \"vertical\",\n                element: el,\n                pos: [\n                    throttle((elementLeft + elementRight) / 2 + distLeft, 0.1),\n                    elementTop,\n                ],\n                size: height,\n                sizes,\n                center: true,\n            });\n            guidelines.push({\n                type: \"horizontal\",\n                element: el,\n                pos: [\n                    elementLeft,\n                    throttle((elementTop + elementBottom) / 2 + distTop, 0.1),\n                ],\n                size: width,\n                sizes,\n                center: true,\n            });\n        }\n    });\n\n    state.guidelines = guidelines;\n    state.enableSnap = true;\n}\n\nexport function hasGuidelines(\n    moveable: MoveableManager<any, any>,\n    ableName: string,\n): moveable is MoveableManager<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n        },\n        state: {\n            guidelines,\n            enableSnap,\n        },\n    } = moveable;\n\n    if (\n        !snappable\n        || !enableSnap\n        || (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        bounds\n        || (guidelines && guidelines.length)\n        || (verticalGuidelines && verticalGuidelines.length)\n        || (horizontalGuidelines && horizontalGuidelines.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nfunction solveNextOffset(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    datas: IObject<any>,\n) {\n    const sizeOffset = solveEquation(\n        pos1,\n        pos2,\n        offset,\n        isVertical,\n    );\n\n    if (!sizeOffset) {\n        return [0, 0];\n    }\n    const [widthOffset, heightOffset] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return [widthOffset, heightOffset];\n}\nfunction getNextFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    direction: number[],\n    is3d: boolean,\n) {\n    const nextPoses = caculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextPos = getPosByReverseDirection(nextPoses, direction);\n\n    return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\nexport function checkSnapBoundsKeepRatio(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n    isRequest: boolean,\n) {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundKeepRatio(\n        moveable,\n        startPos,\n        endPos,\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any : checkSnapKeepRatio(\n        moveable,\n        startPos,\n        endPos,\n    );\n\n    const horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\n    const verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\nexport function checkSnapBounds(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    isRequest: boolean,\n    poses: number[][],\n    boundPoses: number[][] = poses,\n) {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundPoses(\n        moveable,\n        boundPoses.map(pos => pos[0]),\n        boundPoses.map(pos => pos[1]),\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any : checkSnapPoses(\n        moveable,\n        poses.map(pos => pos[0]),\n        poses.map(pos => pos[1]),\n    );\n\n    const horizontalOffset = getSnapBound(horizontalBoundInfo, horizontalSnapInfo);\n    const verticalOffset = getSnapBound(verticalBoundInfo, verticalSnapInfo);\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\nexport function normalized(value: number) {\n    return value ? value / Math.abs(value) : 0;\n}\nexport function checkMaxBounds(\n    moveable: MoveableManager<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    fixedPos: number[],\n    datas: any,\n) {\n    const fixedDirection = [-direction[0], -direction[1]];\n    const {\n        width,\n        height,\n    } = moveable.state;\n    const bounds = moveable.props.bounds;\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n\n    if (bounds) {\n        const directions = [\n            [direction[0], -direction[1]],\n            [-direction[0], direction[1]],\n        ];\n        const {\n            left = -Infinity,\n            top = -Infinity,\n            right = Infinity,\n            bottom = Infinity,\n        } = bounds;\n\n        directions.forEach(otherDirection => {\n            const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            const otherPos = getPosByDirection(poses, otherDirection);\n\n            const verticalDirection = normalized(otherDirection[1] - fixedDirection[1]);\n            const horizontalDirection = normalized(otherDirection[0] - fixedDirection[0]);\n            const deg = getRad(fixedPos, otherPos) * 360 / Math.PI;\n\n            if (isCheckHorizontal) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n                    nextOtherPos[1] = fixedPos[1];\n                }\n                const [\n                    ,\n                    heightOffset,\n                ] = solveNextOffset(\n                    fixedPos, nextOtherPos,\n                    (fixedPos[1] < otherPos[1] ? bottom : top) - otherPos[1],\n                    false, datas,\n                );\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + verticalDirection * heightOffset;\n                }\n            }\n            if (isCheckVertical) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n                    nextOtherPos[0] = fixedPos[0];\n                }\n                const [\n                    widthOffset,\n                ] = solveNextOffset(\n                    fixedPos, nextOtherPos,\n                    (fixedPos[0] < otherPos[0] ? right : left) - otherPos[0],\n                    true, datas,\n                );\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + horizontalDirection * widthOffset;\n                }\n            }\n        });\n    }\n    return {\n        maxWidth,\n        maxHeight,\n    };\n}\nfunction getSnapBoundInfo(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    poses: number[][],\n    directions: number[][][],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any,\n) {\n    return directions.map(([startDirection, endDirection]) => {\n        const otherStartPos = getPosByDirection(poses, startDirection);\n        const otherEndPos = getPosByDirection(poses, endDirection);\n        const snapBoundInfo\n            = keepRatio\n                ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest)\n                : checkSnapBounds(moveable, isRequest, [otherEndPos]);\n\n        const {\n            horizontal: {\n                dist: otherHorizontalDist,\n                offset: otherHorizontalOffset,\n                isBound: isOtherHorizontalBound,\n                isSnap: isOtherHorizontalSnap,\n            },\n            vertical: {\n                dist: otherVerticalDist,\n                offset: otherVerticalOffset,\n                isBound: isOtherVerticalBound,\n                isSnap: isOtherVerticalSnap,\n            },\n        } = snapBoundInfo;\n\n        const multiple = minus(endDirection, startDirection);\n\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [0, 0],\n            };\n        }\n        const isVertical = otherHorizontalDist < otherVerticalDist;\n        const sizeOffset = solveNextOffset(\n            otherStartPos,\n            otherEndPos,\n            -(isVertical ? otherVerticalOffset : otherHorizontalOffset),\n            isVertical,\n            datas,\n        ).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset,\n        };\n    });\n}\nexport function getCheckSnapDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const directions: number[][][] = [];\n    const fixedDirection = [-direction[0], -direction[1]];\n\n    if (direction[0] && direction[1]) {\n        directions.push(\n            [fixedDirection, [direction[0], -direction[1]]],\n            [fixedDirection, [-direction[0], direction[1]]],\n        );\n        if (keepRatio) {\n            // pass two direction condition\n            directions.push(\n                [fixedDirection, direction],\n            );\n        }\n    } else if (direction[0]) {\n        // vertcal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [fixedDirection[0], -1]],\n                [fixedDirection, [fixedDirection[0], 1]],\n                [fixedDirection, [direction[0], -1]],\n                [fixedDirection, direction],\n                [fixedDirection, [direction[0], 1]],\n            );\n        } else {\n            directions.push(\n                [[fixedDirection[0], -1], [direction[0], -1]],\n                [[fixedDirection[0], 0], [direction[0], 0]],\n                [[fixedDirection[0], 1], [direction[0], 1]],\n            );\n        }\n    } else if (direction[1]) {\n        // horizontal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [-1, fixedDirection[1]]],\n                [fixedDirection, [1, fixedDirection[1]]],\n                [fixedDirection, [-1, direction[1]]],\n                [fixedDirection, [1, direction[1]]],\n                [fixedDirection, direction],\n            );\n        } else {\n            directions.push(\n                [[-1, fixedDirection[1]], [-1, direction[1]]],\n                [[0, fixedDirection[1]], [0, direction[1]]],\n                [[1, fixedDirection[1]], [1, direction[1]]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        directions.push(\n            [fixedDirection, [1, 0]],\n            [fixedDirection, [-1, 0]],\n            [fixedDirection, [0, -1]],\n            [fixedDirection, [0, 1]],\n\n            [[1, 0], [1, -1]],\n            [[1, 0], [1, 1]],\n            [[0, 1], [1, 1]],\n            [[0, 1], [-1, 1]],\n\n            [[-1, 0], [-1, -1]],\n            [[-1, 0], [-1, 1]],\n            [[0, -1], [1, -1]],\n            [[0, -1], [-1, -1]],\n        );\n    }\n\n    return directions;\n}\nexport function getSizeOffsetInfo(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any,\n) {\n    const directions = getCheckSnapDirections(direction, keepRatio);\n    const lines = getCheckSnapLines(poses, direction, keepRatio);\n    const offsets = [\n        ...getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas),\n        ...getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas),\n    ];\n    const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0],\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1],\n        },\n    };\n}\nexport function recheckSizeByTwoDirection(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    poses: number[][],\n    width: number,\n    height: number,\n    maxWidth: number,\n    maxHeight: number,\n    direction: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const snapPos = getPosByDirection(poses, direction);\n\n    const {\n        horizontal: {\n            offset: horizontalOffset,\n        },\n        vertical: {\n            offset: verticalOffset,\n        },\n    } = checkSnapBounds(moveable, isRequest, [snapPos]);\n\n    if (verticalOffset || horizontalOffset) {\n        const [nextWidthOffset, nextHeightOffset] = getDragDist({\n            datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset,\n        });\n\n        const nextWidth\n            = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\n        const nextHeight\n            = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\n\n        return [\n            nextWidth - width,\n            nextHeight - height,\n        ];\n    }\n    return [\n        0,\n        0,\n    ];\n}\nexport function checkSizeDist(\n    moveable: MoveableManager<any, any>,\n    getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const keepRatio = moveable.props.keepRatio;\n\n    let widthOffset = 0;\n    let heightOffset = 0;\n\n    for (let i = 0; i < 2; ++i) {\n        const nextPoses = getNextPoses(widthOffset, heightOffset);\n        const {\n            width: widthOffsetInfo,\n            height: heightOffsetInfo,\n        } = getSizeOffsetInfo(\n            moveable,\n            nextPoses,\n            direction,\n            keepRatio,\n            isRequest,\n            datas,\n        );\n\n        const isWidthBound = widthOffsetInfo.isBound;\n        const isHeightBound = heightOffsetInfo.isBound;\n        let nextWidthOffset = widthOffsetInfo.offset;\n        let nextHeightOffset = heightOffsetInfo.offset;\n\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [0, 0];\n        }\n        if (keepRatio) {\n            const widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n            const heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n            const isGetWidthOffset\n                = isWidthBound && isHeightBound ? widthDist < heightDist\n                    : isHeightBound || (!isWidthBound && widthDist < heightDist);\n\n            // height * widthOffset = width * heighOffset\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = width * nextHeightOffset / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = height * nextWidthOffset / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    if (direction[0] && direction[1]) {\n        const {\n            maxWidth,\n            maxHeight,\n        } = checkMaxBounds(moveable, poses, direction, fixedPos, datas);\n\n        const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n            moveable,\n            getNextPoses(widthOffset, heightOffset),\n            width + widthOffset,\n            height + heightOffset,\n            maxWidth,\n            maxHeight,\n            direction,\n            isRequest,\n            datas,\n        );\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    return [\n        widthOffset,\n        heightOffset,\n    ];\n}\n\nexport function checkSnapRotate(\n    moveable: MoveableManager<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    origin: number[],\n    rotation: number,\n) {\n    if (!hasGuidelines(moveable, \"rotatable\")) {\n        return rotation;\n    }\n\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = rect;\n    const rad = rotation * Math.PI / 180;\n    const prevPoses = [pos1, pos2, pos3, pos4].map(pos => minus(pos, origin));\n    const nextPoses = prevPoses.map(pos => rotate(pos, rad));\n\n    const result = [\n        ...checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation),\n        ...checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation),\n    ];\n    result.sort((a, b) => Math.abs(a - rotation) - Math.abs(b - rotation));\n\n    if (result.length) {\n        return result[0];\n    } else {\n        return rotation;\n    }\n}\nexport function checkSnapSize(\n    moveable: MoveableManager<any, any>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const {\n        matrix,\n        is3d,\n    } = moveable.state;\n    return checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                matrix,\n                width + widthOffset,\n                height + heightOffset,\n                fixedPos,\n                direction,\n                is3d,\n            );\n        }, width, height, direction, fixedPos, isRequest, datas,\n    );\n}\nexport function checkSnapScale(\n    moveable: MoveableManager<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const {\n        width,\n        height,\n    } = datas;\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const is3d = datas.is3d;\n    const sizeDist = checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                scaleMatrix(datas, plus(scale, [widthOffset / width, heightOffset / height])),\n                width,\n                height,\n                fixedPos,\n                direction,\n                is3d,\n            );\n        },\n        width, height,\n        direction,\n        fixedPos,\n        isRequest,\n        datas,\n    );\n\n    return [\n        sizeDist[0] / width,\n        sizeDist[1] / height,\n    ];\n}\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean,\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return [0, 0];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return [0, 0];\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\nexport function startCheckSnapDrag(\n    moveable: MoveableManager<any, any>,\n    datas: any,\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\nexport function checkThrottleDragRotate(\n    throttleDragRotate: number,\n    [distX, distY]: number[],\n    [isVerticalBound, isHorizontalBound]: boolean[],\n    [isVerticalSnap, isHorizontalSnap]: boolean[],\n    [verticalOffset, horizontalOffset]: number[],\n) {\n    let offsetX = -verticalOffset;\n    let offsetY = -horizontalOffset;\n\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        const adjustPoses = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n                [verticalOffset, 0],\n            );\n        } else if (isVerticalBound) {\n            adjustPoses.push(\n                [verticalOffset, 0],\n            );\n        } else if (isHorizontalBound) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n            );\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n                [verticalOffset, 0],\n            );\n        } else if (isVerticalSnap) {\n            adjustPoses.push(\n                [verticalOffset, 0],\n            );\n        } else if (isHorizontalSnap) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n            );\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort((a, b) => {\n                return getDistSize(minus([distX, distY], a)) - getDistSize(minus([distX, distY], b));\n            });\n            const adjustPos = adjustPoses[0];\n\n            if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;\n            } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n                const prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (Math.abs(offsetX) > TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {\n                    const scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (Math.abs(offsetY) > TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {\n                    const scale = Math.abs(horizontalOffset) / Math.abs(offsetY);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = (distX || isVerticalBound) ? -verticalOffset : 0;\n        offsetY = (distY || isHorizontalBound) ? -horizontalOffset : 0;\n    }\n    return [offsetX, offsetY];\n}\nexport function checkSnapDrag(\n    moveable: MoveableManager<SnappableProps & DraggableProps, any>,\n    distX: number,\n    distY: number,\n    throttleDragRotate: number,\n    isRequest: boolean,\n    datas: any,\n) {\n\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n        ];\n    }\n    const poses = getAbsolutePoses(\n        datas.absolutePoses,\n        [distX, distY],\n    );\n    const { left, right, top, bottom } = getRect(poses);\n    const snapCenter = moveable.props.snapCenter;\n    const snapPoses = [\n        [left, top],\n        [right, top],\n        [left, bottom],\n        [right, bottom],\n    ];\n\n    if (snapCenter) {\n        snapPoses.push([(left + right) / 2, (top + bottom) / 2]);\n    }\n    const {\n        vertical: verticalSnapBoundInfo,\n        horizontal: horizontalSnapBoundInfo,\n    } = checkSnapBounds(moveable, isRequest, snapPoses, poses);\n    const {\n        vertical: verticalInnerBoundInfo,\n        horizontal: horizontalInnerBoundInfo,\n    } = getInnerBoundDragInfo(moveable, poses, datas);\n\n    const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    const isVerticalBound\n        = verticalSnapBoundInfo.isBound\n        || verticalInnerBoundInfo.isBound;\n    const isHorizontalBound\n        = horizontalSnapBoundInfo.isBound\n        || horizontalInnerBoundInfo.isBound;\n    const verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\n    const horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\n    const [offsetX, offsetY] = checkThrottleDragRotate(\n        throttleDragRotate,\n        [distX, distY],\n        [isVerticalBound, isHorizontalBound],\n        [isVerticalSnap, isHorizontalSnap],\n        [verticalOffset, horizontalOffset],\n    );\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX,\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY,\n        },\n    ];\n}\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: Guideline[] = [];\n\n    posInfos.forEach(posInfo => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (guidelines.indexOf(guideline) > -1) {\n                return;\n            }\n            guidelines.push(guideline);\n        });\n    });\n\n    return guidelines;\n}\n\nfunction getElementGuidelineDist(\n    elementPos: number,\n    elementSize: number,\n    targetPos: number,\n    targetSize: number,\n) {\n    // relativePos < 0  => element(l)  ---  (r)target\n    // relativePos > 0  => target(l)   ---  (r)element\n    const relativePos = elementPos - targetPos;\n    const startPos = relativePos < 0 ? relativePos + elementSize : targetSize;\n    const endPos = relativePos < 0 ? 0 : relativePos;\n    const size = endPos - startPos;\n\n    return {\n        size,\n        pos: startPos,\n    };\n}\nfunction groupByElementGuidelines(\n    guidelines: Guideline[],\n    clientPos: number,\n    size: number,\n    index: number,\n) {\n    const groupInfos: Array<[Element, number, any]> = [];\n\n    const group = groupBy(guidelines.filter(({ element, gap }) => element && !gap), ({ element, pos }) => {\n        const elementPos = pos[index];\n        const sign = Math.min(0, elementPos - clientPos) < 0 ? -1 : 1;\n        const groupKey = `${sign}_${pos[index ? 0 : 1]}`;\n        const groupInfo = find(groupInfos, ([groupElement, groupPos]) => {\n            return element === groupElement && elementPos === groupPos;\n        });\n        if (groupInfo) {\n            return groupInfo[2];\n        }\n        groupInfos.push([element!, elementPos, groupKey]);\n        return groupKey;\n    });\n    group.forEach(elementGuidelines => {\n        elementGuidelines.sort((a, b) => {\n            const result = getElementGuidelineDist(a.pos[index], a.size, clientPos, size).size\n                - getElementGuidelineDist(b.pos[index], a.size, clientPos, size).size;\n\n            return result || a.pos[index ? 0 : 1] - b.pos[index ? 0 : 1];\n        });\n    });\n    return group;\n}\nfunction renderElementGroup(\n    group: Guideline[][],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    minPos: number,\n    clientPos: number,\n    clientSize: number,\n    targetPos: number,\n    snapThreshold: number,\n    isDisplaySnapDigit: boolean,\n    snapDigit: number,\n    index: number,\n    snapDistFormat: Required<SnappableOptions>[\"snapDistFormat\"],\n    React: Renderer,\n) {\n    return flat(group.map((elementGuidelines, i) => {\n        let isFirstRenderSize = true;\n\n        return elementGuidelines.map(({ pos, size }, j) => {\n            const {\n                pos: linePos,\n                size: lineSize,\n            } = getElementGuidelineDist(pos[index], size, clientPos, clientSize);\n\n            if (lineSize < snapThreshold) {\n                return null;\n            }\n            const isRenderSize = isFirstRenderSize;\n\n            isFirstRenderSize = false;\n            const snapSize = isDisplaySnapDigit && isRenderSize ? parseFloat(lineSize.toFixed(snapDigit)) : 0;\n\n            return <div className={prefix(\n                \"line\",\n                directionName,\n                \"guideline\",\n                \"dashed\",\n            )}\n                data-size={snapSize > 0 ? snapDistFormat(snapSize) : \"\"}\n                key={`${directionName}LinkGuidline${i}-${j}`} style={{\n                    [posName1]: `${minPos + linePos}px`,\n                    [posName2]: `${-targetPos + pos[index ? 0 : 1]}px`,\n                    [sizeName]: `${lineSize}px`,\n                }} />;\n        });\n    }));\n}\nfunction renderSnapPoses(\n    snapPoses: number[],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    minPos: number,\n    targetPos: number,\n    size: number,\n    React: Renderer,\n) {\n    return snapPoses.map((pos, i) => {\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            \"target\",\n            \"bold\",\n        )} key={`${directionName}TargetGuidline${i}`} style={{\n            [posName1]: `${minPos}px`,\n            [posName2]: `${-targetPos + pos}px`,\n            [sizeName]: `${size}px`,\n        }} />;\n    });\n}\nfunction renderGuidelines(\n    guidelines: Guideline[],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    targetPos1: number,\n    targetPos2: number,\n    index: number,\n    React: Renderer,\n) {\n    return guidelines.map((guideline, i) => {\n        const { pos, size, element } = guideline;\n\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            element ? \"bold\" : \"\",\n        )} key={`${directionName}Guidline${i}`} style={{\n            [posName1]: `${-targetPos1 + pos[index]}px`,\n            [posName2]: `${-targetPos2 + pos[index ? 0 : 1]}px`,\n            [sizeName]: `${size}px`,\n        }} />;\n    });\n}\n\nfunction getGapGuidelinesToStart(\n    guidelines: Guideline[],\n    index: number,\n    targetPos: number[],\n    targetSizes: number[],\n    guidelinePos: number[],\n    gap: number,\n    otherPos: number,\n): GapGuideline[] {\n    const absGap = Math.abs(gap);\n    let start = guidelinePos[index] + (gap > 0 ? targetSizes[0] : 0);\n\n    return guidelines.filter(({ pos: gapPos }) => gapPos[index] <= targetPos[index])\n        .sort(({ pos: aPos }, { pos: bPos }) => bPos[index] - aPos[index])\n        .filter(({ pos: gapPos, sizes: gapSizes }) => {\n            const nextPos = gapPos[index];\n\n            if (throttle(nextPos + gapSizes![index], 0.0001) === throttle(start - absGap, 0.0001)) {\n                start = nextPos;\n                return true;\n            }\n            return false;\n        }).map(gapGuideline => {\n            const renderPos = -targetPos[index] + gapGuideline.pos[index] + gapGuideline.sizes![index];\n\n            return {\n                ...gapGuideline,\n                gap,\n                renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos],\n            };\n        });\n}\nfunction getGapGuidelinesToEnd(\n    guidelines: Guideline[],\n    index: number,\n    targetPos: number[],\n    targetSizes: number[],\n    guidelinePos: number[],\n    gap: number,\n    otherPos: number,\n): GapGuideline[] {\n    const absGap = Math.abs(gap);\n    let start = guidelinePos[index] + (gap < 0 ? targetSizes[index] : 0);\n\n    return guidelines.filter(({ pos: gapPos }) => gapPos[index] > targetPos[index])\n        .sort(({ pos: aPos }, { pos: bPos }) => aPos[index] - bPos[index])\n        .filter(({ pos: gapPos, sizes: gapSizes }) => {\n            const nextPos = gapPos[index];\n\n            if (throttle(nextPos, 0.0001) === throttle(start + absGap, 0.0001)) {\n                start = nextPos + gapSizes![index];\n                return true;\n            }\n            return false;\n        }).map(gapGuideline => {\n            const renderPos = -targetPos[index] + gapGuideline.pos[index] - absGap;\n\n            return {\n                ...gapGuideline,\n                gap,\n                renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos],\n            };\n        });\n}\nfunction getGapGuidelines(\n    guidelines: Guideline[],\n    type: \"vertical\" | \"horizontal\",\n    targetPos: number[],\n    targetSizes: number[],\n): GapGuideline[] {\n    const elementGuidelines = guidelines.filter(\n        ({ element, gap, type: guidelineType }) => element && gap && guidelineType === type);\n    const [index, otherIndex] = type === \"vertical\" ? [0, 1] : [1, 0];\n\n    return flat(elementGuidelines.map((guideline, i) => {\n        const pos = guideline.pos;\n        const gap = guideline.gap!;\n        const gapGuidelines = guideline.gapGuidelines!;\n        const sizes = guideline.sizes!;\n\n        let offset = minOffset(\n            pos[otherIndex] + sizes[otherIndex] - targetPos[otherIndex],\n            pos[otherIndex] - targetPos[otherIndex] - targetSizes[otherIndex],\n        );\n        const minSize = Math.min(sizes[otherIndex], targetSizes[otherIndex]);\n\n        if (offset > 0 && offset > minSize) {\n            offset = (offset - minSize / 2) * 2;\n        } else if (offset < 0 && offset < -minSize) {\n            offset = (offset + minSize / 2) * 2;\n        }\n\n        const otherPos = (offset > 0 ? 0 : targetSizes[otherIndex]) + offset / 2;\n        return [\n            ...getGapGuidelinesToStart(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos),\n            ...getGapGuidelinesToEnd(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos),\n        ];\n    }));\n}\nfunction renderGapGuidelines(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    gapGuidelines: GapGuideline[],\n    type: \"vertical\" | \"horizontal\",\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    snapDistFormat: Required<SnappableOptions>[\"snapDistFormat\"],\n    React: any,\n) {\n    const {\n        snapDigit = 0,\n        isDisplaySnapDigit = true,\n    } = moveable.props;\n\n    const otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n    const [index, otherIndex] = type === \"vertical\" ? [0, 1] : [1, 0];\n\n    return gapGuidelines.map(({ renderPos, gap }, i) => {\n        const absGap = Math.abs(gap!);\n        const snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;\n\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            \"gap\",\n        )}\n            data-size={snapSize > 0 ? snapDistFormat(snapSize) : \"\"}\n            key={`${otherType}GapGuideline${i}`} style={{\n                [posName1]: `${renderPos[index]}px`,\n                [posName2]: `${renderPos[otherIndex]}px`,\n                [sizeName]: `${absGap}px`,\n            }} />;\n    });\n}\n\nfunction addBoundGuidelines(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    verticalSnapPoses: number[],\n    horizontalSnapPoses: number[],\n) {\n    const {\n        vertical: {\n            isBound: isVerticalBound,\n            pos: verticalBoundPos,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            pos: horizontalBoundPos,\n        },\n    } = checkBoundPoses(moveable, verticalPoses, horizontalPoses);\n\n    if (isVerticalBound && verticalSnapPoses.indexOf(verticalBoundPos) < 0) {\n        verticalSnapPoses.push(verticalBoundPos);\n    }\n    if (isHorizontalBound && horizontalSnapPoses.indexOf(horizontalBoundPos) < 0) {\n        horizontalSnapPoses.push(horizontalBoundPos);\n    }\n    const {\n        vertical: verticalInnerBoundPoses,\n        horizontal: horizontalInnerBoundPoses,\n    } = checkInnerBoundPoses(moveable);\n\n    verticalSnapPoses.push(\n        ...verticalInnerBoundPoses.filter(pos => verticalSnapPoses.indexOf(pos) < 0),\n    );\n    horizontalSnapPoses.push(\n        ...horizontalInnerBoundPoses.filter(pos => horizontalSnapPoses.indexOf(pos) < 0),\n    );\n}\nexport default {\n    name: \"snappable\",\n    props: {\n        snappable: [Boolean, Array],\n        snapCenter: Boolean,\n        snapHorizontal: Boolean,\n        snapVertical: Boolean,\n        snapElement: Boolean,\n        snapGap: Boolean,\n        isDisplaySnapDigit: Boolean,\n        snapDigit: Number,\n        snapThreshold: Number,\n        horizontalGuidelines: Array,\n        verticalGuidelines: Array,\n        elementGuidelines: Array,\n        bounds: Object,\n        innerBounds: Object,\n    } as const,\n    render(moveable: MoveableManager<SnappableProps, SnappableState>, React: Renderer): any[] {\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1, pos2, pos3, pos4,\n            snapRenderInfo,\n            targetClientRect,\n            containerClientRect,\n            is3d,\n            rootMatrix,\n        } = moveable.state;\n\n        if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n\n        const n = is3d ? 4 : 3;\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n        const containerPos = caculateContainerPos(rootMatrix, containerClientRect, n);\n        const [clientLeft, clientTop] = caculateInversePosition(rootMatrix, [\n            targetClientRect.left - containerPos[0],\n            targetClientRect.top - containerPos[1],\n        ], n);\n\n        const {\n            snapThreshold = 5,\n            snapDigit = 0,\n            isDisplaySnapDigit = true,\n            snapDistFormat = (v: number) => v,\n        } = moveable.props;\n        const poses = getAbsolutePosesByState(moveable.state);\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const verticalSnapPoses: number[] = [];\n        const horizontalSnapPoses: number[] = [];\n        const verticalGuidelines: Guideline[] = [];\n        const horizontalGuidelines: Guideline[] = [];\n        const snapInfos: Array<{ vertical: SnapInfo, horizontal: SnapInfo }> = [];\n\n        if (!snapRenderInfo.request) {\n            if (snapRenderInfo.direction) {\n                snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));\n            }\n            if (snapRenderInfo.snap) {\n                const rect = getRect(poses);\n\n                if (snapRenderInfo.center) {\n                    (rect as any).middle = (rect.top + rect.bottom) / 2;\n                    (rect as any).center = (rect.left + rect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, rect, true, 1));\n            }\n            snapInfos.forEach(snapInfo => {\n                const {\n                    vertical: {\n                        posInfos: verticalPosInfos,\n                    },\n                    horizontal: {\n                        posInfos: horizontalPosInfos,\n                    },\n                } = snapInfo;\n                verticalSnapPoses.push(...verticalPosInfos.map(posInfo => posInfo.pos));\n                horizontalSnapPoses.push(...horizontalPosInfos.map(posInfo => posInfo.pos));\n                verticalGuidelines.push(...getSnapGuidelines(verticalPosInfos));\n                horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n            });\n        }\n        addBoundGuidelines(\n            moveable,\n            [left, right],\n            [top, bottom],\n            verticalSnapPoses,\n            horizontalSnapPoses,\n        );\n        const elementHorizontalGroup = groupByElementGuidelines(\n            horizontalGuidelines,\n            clientLeft,\n            width,\n            0,\n        );\n        const elementVerticalGroup = groupByElementGuidelines(\n            verticalGuidelines,\n            clientTop,\n            height,\n            1,\n        );\n        const horizontalNames = [\"horizontal\", \"left\", \"top\", \"width\"] as const;\n        const verticalNames = [\"vertical\", \"top\", \"left\", \"height\"] as const;\n\n        const gapVerticalGuidelines = getGapGuidelines(\n            verticalGuidelines, \"vertical\",\n            [targetLeft, targetTop],\n            [width, height],\n        );\n        const gapHorizontalGuidelines = getGapGuidelines(\n            horizontalGuidelines, \"horizontal\",\n            [targetLeft, targetTop],\n            [width, height],\n        );\n\n        const allGuidelines = [\n            ...verticalGuidelines,\n            ...horizontalGuidelines,\n        ];\n        triggerEvent(moveable, \"onSnap\", {\n            guidelines: allGuidelines.filter(({ element }) => !element),\n            elements: groupBy(allGuidelines.filter(({ element }) => element), ({ element }) => element),\n            gaps: [\n                ...gapVerticalGuidelines,\n                ...gapHorizontalGuidelines,\n            ],\n        }, true);\n\n        return [\n            ...renderGapGuidelines(\n                moveable,\n                gapVerticalGuidelines,\n                \"vertical\",\n                horizontalNames,\n                snapDistFormat,\n                React,\n            ),\n            ...renderGapGuidelines(\n                moveable,\n                gapHorizontalGuidelines,\n                \"horizontal\",\n                verticalNames,\n                snapDistFormat,\n                React,\n            ),\n            ...renderElementGroup(\n                elementHorizontalGroup,\n                horizontalNames,\n                minLeft,\n                clientLeft,\n                width,\n                targetTop,\n                snapThreshold,\n                isDisplaySnapDigit,\n                snapDigit,\n                0,\n                snapDistFormat,\n                React,\n            ),\n            ...renderElementGroup(\n                elementVerticalGroup,\n                verticalNames,\n                minTop,\n                clientTop,\n                height,\n                targetLeft,\n                snapThreshold,\n                isDisplaySnapDigit,\n                snapDigit,\n                1,\n                snapDistFormat,\n                React,\n            ),\n            ...renderSnapPoses(\n                horizontalSnapPoses,\n                horizontalNames,\n                minLeft,\n                targetTop,\n                width,\n                React,\n            ),\n            ...renderSnapPoses(\n                verticalSnapPoses,\n                verticalNames,\n                minTop,\n                targetLeft,\n                height,\n                React,\n            ),\n            ...renderGuidelines(\n                horizontalGuidelines,\n                horizontalNames,\n                targetLeft,\n                targetTop,\n                0,\n                React,\n            ),\n            ...renderGuidelines(\n                verticalGuidelines,\n                verticalNames,\n                targetTop,\n                targetLeft,\n                1,\n                React,\n            ),\n        ];\n    },\n    dragStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        snapStart(moveable);\n    },\n    pinchStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragControlCondition(e: any) {\n        return directionCondition(e) || rotatableDragControlCondtion(e);\n    },\n    dragControlStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragControlEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroupEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(moveable: any, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragGroupControlEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n    },\n};\n","import { getDragDist, setDragStart } from \"../DraggerUtils\";\nimport { throttleArray, triggerEvent, fillParams, throttle, getDistSize, prefix } from \"../utils\";\nimport { minus, plus, getRad } from \"@moveable/matrix\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState, Renderer, OnDragGroupEnd,\n} from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildDragger } from \"../groupUtils\";\nimport { checkSnapDrag, startCheckSnapDrag } from \"./Snappable\";\nimport { IObject } from \"@daybrush/utils\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n */\nexport default {\n    name: \"draggable\",\n    props: {\n        draggable: Boolean,\n        throttleDrag: Number,\n        throttleDragRotate: Number,\n    },\n    render(\n        moveable: MoveableManager<DraggableProps, DraggableState>,\n        React: Renderer,\n    ) {\n        const throttleDragRotate = moveable.props.throttleDragRotate;\n        const { dragInfo, beforeOrigin } = moveable.state;\n\n        if (!throttleDragRotate || !dragInfo) {\n            return;\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return;\n        }\n\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return <div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad)`,\n        }} />;\n    },\n    dragStart(\n        moveable: MoveableManager<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentDragger } = e;\n        const state = moveable.state;\n        const {\n            targetTransform,\n            target,\n            dragger,\n        } = state;\n\n        if (dragger) {\n            return false;\n        }\n        state.dragger = parentDragger || moveable.targetDragger;\n        const style = window.getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.transform = targetTransform;\n        datas.startTranslate = [0, 0];\n\n        setDragStart(moveable, { datas });\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n\n        startCheckSnapDrag(moveable, datas);\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startTranslate = translate;\n            },\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            state.dragger = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManager<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        const { datas, parentEvent, parentFlag, isPinch, isRequest } = e;\n        let { distX, distY } = e;\n        const { isDrag, prevDist, prevBeforeDist, transform, startTranslate } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let isSnap = false;\n        let dragRotateRad = 0;\n\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n            const deg = throttle(getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate);\n            const r = getDistSize([distX, distY]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag && (distX || distY)) {\n            const [verticalInfo, horizontalInfo] = checkSnapDrag(\n                moveable, distX, distY, throttleDragRotate, isRequest, datas,\n            );\n            const {\n                isSnap: isVerticalSnap,\n                isBound: isVerticalBound,\n                offset: verticalOffset,\n            } = verticalInfo;\n            const {\n                isSnap: isHorizontalSnap,\n                isBound: isHorizontalBound,\n                offset: horizontalOffset,\n            } = horizontalInfo;\n            isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n        datas.passDeltaX = distX - (datas.passDistX || 0);\n        datas.passDeltaY = distY - (datas.passDistY || 0);\n        datas.passDistX = distX;\n        datas.passDistY = distY;\n        const beforeTranslate = plus(getDragDist({ datas, distX, distY }, true), startTranslate);\n        const translate = plus(getDragDist({ datas, distX, distY }, false), startTranslate);\n\n        if (!throttleDragRotate && !isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n\n        const beforeDist = minus(beforeTranslate, startTranslate);\n        const dist = minus(translate, startTranslate);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = `${transform} translate(${dist[0]}px, ${dist[1]}px)`;\n\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            isPinch,\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragEnd(\n        moveable: MoveableManager<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas, isDrag } = e;\n\n        moveable.state.dragger = null;\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", fillParams<OnDragEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        const { datas, clientX, clientY } = e;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildDragger(moveable, this, \"dragStart\", [\n            clientX || 0,\n            clientY || 0,\n        ], e, false);\n\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDeltaX, passDeltaY } = e.datas;\n        const events = triggerChildDragger(moveable, this, \"drag\", [passDeltaX, passDeltaY], e, false);\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        triggerChildDragger(moveable, this, \"dragEnd\", [0, 0], e, false);\n        triggerEvent(moveable, \"onDragGroupEnd\", fillParams<OnDragGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        }));\n\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10, isInstant: true });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100, isInstant: true });\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100, isInstant: true });\n     * moveable.request(\"draggable\", { x: 220, y: 100, isInstant: true });\n     * moveable.request(\"draggable\", { x: 240, y: 100, isInstant: true });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManager<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        return {\n            isControl: false,\n            requestStart(e: IObject<any>) {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n\n                return { datas, distX, distY };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n    unset(moveable: any) {\n        moveable.state.dragInfo = null;\n    },\n};\n","import { throttle, prefix, triggerEvent, fillParams, getRotationRad, getClientRect, caculatePosition } from \"../utils\";\nimport { IObject, hasClass } from \"@daybrush/utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate,\n    OnRotateEnd, MoveableClientRect, SnappableProps, SnappableState,\n} from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { minus, plus, getRad, rotate as rotateMatrix } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapRotate } from \"./Snappable\";\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n */\n\nfunction setRotateStartInfo(\n    moveable: MoveableManager<any, any>,\n    datas: IObject<any>, clientX: number, clientY: number, origin: number[], rect: MoveableClientRect) {\n\n    const n = moveable.state.is3d ? 4 : 3;\n    const nextOrigin = caculatePosition(moveable.state.rootMatrix, origin, n);\n    const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\n    datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.prevSnapDeg = datas.prevDeg;\n    datas.startDeg = datas.prevDeg;\n    datas.loop = 0;\n}\nfunction getParentDeg(\n    moveable: MoveableManager<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    parentDist: number,\n    direction: number,\n    startRotate: number,\n) {\n    const {\n        prevDeg,\n    } = datas;\n\n    const absoluteDeg = startRotate + parentDist;\n    const dist = checkSnapRotate(\n        moveable,\n        moveableRect,\n        datas.origin,\n        parentDist,\n    );\n    datas.prevDeg = dist;\n\n    const delta = direction * (dist - prevDeg);\n\n    return [delta, dist, absoluteDeg];\n}\nfunction getDeg(\n    moveable: MoveableManager<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    deg: number,\n    direction: number,\n    startRotate: number,\n    throttleRotate: number,\n    isSnap?: boolean,\n) {\n    const {\n        prevDeg,\n        prevSnapDeg,\n        startDeg,\n        loop: prevLoop,\n    } = datas;\n\n    if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++datas.loop;\n    } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --datas.loop;\n    }\n    const loop = datas.loop;\n    const absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startRotate;\n    let absoluteDeg = loop * 360 + deg - startDeg + startRotate;\n\n    datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    absoluteDeg = throttle(absoluteDeg, throttleRotate);\n    let dist = direction * (absoluteDeg - startRotate);\n    if (isSnap) {\n        dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);\n        absoluteDeg = dist / direction + startRotate;\n    }\n    datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    const delta = direction * (absoluteDeg - absolutePrevSnapDeg);\n\n    return [delta, dist, absoluteDeg];\n}\nfunction getRotateInfo(\n    moveable: MoveableManager<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    direction: number,\n    clientX: number, clientY: number,\n    startRotate: number,\n    throttleRotate: number,\n) {\n    return getDeg(\n        moveable,\n        moveableRect,\n        datas,\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        startRotate,\n        throttleRotate,\n        true,\n    );\n}\n\nexport function getPositions(\n    rotationPosition: \"top\" | \"bottom\" | \"left\" | \"right\",\n    [pos1, pos2, pos3, pos4]: number[][],\n) {\n    if (rotationPosition === \"left\") {\n        return [pos3, pos1];\n    } else if (rotationPosition === \"right\") {\n        return [pos2, pos4];\n    } else if (rotationPosition === \"bottom\") {\n        return [pos4, pos3];\n    }\n    return [pos1, pos2];\n}\n\nexport function dragControlCondition(e: any) {\n    if (e.isRequest) {\n        return true;\n    }\n    return hasClass(e.inputEvent.target, prefix(\"rotation\"));\n}\n\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n    props: {\n        rotatable: Boolean,\n        rotationPosition: String,\n        throttleRotate: Number,\n    },\n    render(moveable: MoveableManager<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n        } = moveable.props;\n        if (!rotatable) {\n            return null;\n        }\n        const { renderPoses, direction } = moveable.state;\n        const poses = getPositions(rotationPosition!, renderPoses);\n        const rotationRad = getRotationRad(poses, direction);\n\n        return (\n            <div key=\"rotation\" className={prefix(\"line rotation-line\")} style={{\n                // tslint:disable-next-line: max-line-length\n                transform: `translate(-50%) translate(${(poses[0][0] + poses[1][0]) / 2}px, ${(poses[0][1] + poses[1][1]) / 2}px) rotate(${rotationRad}rad)`,\n            }}>\n                <div className={prefix(\"control\", \"rotation\")}></div>\n            </div>\n        );\n    },\n    dragControlCondition,\n    dragControlStart(\n        moveable: MoveableManager<RotatableProps & SnappableProps, SnappableState>,\n        e: any) {\n        const {\n            datas,\n            clientX, clientY,\n            parentRotate, parentFlag, isPinch,\n            isRequest,\n        } = e;\n        const {\n            target, left, top, origin, beforeOrigin,\n            direction, beforeDirection, targetTransform,\n        } = moveable.state;\n\n        if (!isRequest && !target) {\n            return false;\n        }\n\n        const rect = moveable.getRect();\n        datas.rect = rect;\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n\n        if (isRequest || isPinch || parentFlag) {\n            const externalRotate = parentRotate || 0;\n\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin,\n                prevDeg: externalRotate,\n                startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n            datas.afterInfo = {\n                origin: rect.origin,\n                prevDeg: externalRotate, startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n        } else {\n            datas.beforeInfo = { origin: rect.beforeOrigin };\n            datas.afterInfo = { origin: rect.origin };\n\n            const controlRect = getClientRect(moveable.controlBox.getElement());\n\n            setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, controlRect);\n            setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, controlRect);\n        }\n\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startRotate = 0;\n        datas.datas = {};\n\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startRotate = rotatation;\n            },\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n        };\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<RotatableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, isPinch } = e;\n        const {\n            direction,\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            isRotate,\n            startRotate,\n            rect,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n        const {\n            throttleRotate = 0,\n            parentMoveable,\n        } = moveable.props;\n\n        let delta: number;\n        let dist: number;\n        let rotate: number;\n        let beforeDelta: number;\n        let beforeDist: number;\n        let beforeRotate: number;\n\n        if (\"parentDist\" in e) {\n            const parentDist = e.parentDist;\n\n            [delta, dist, rotate]\n                = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getParentDeg(moveable, rect, beforeInfo, parentDist, direction, startRotate);\n        } else if (isPinch || parentFlag) {\n            [delta, dist, rotate]\n                = getDeg(moveable, rect, afterInfo, parentRotate, direction, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getDeg(moveable, rect, beforeInfo, parentRotate, direction, startRotate, throttleRotate);\n        } else {\n            [delta, dist, rotate]\n                = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate] = getRotateInfo(\n                moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate,\n            );\n        }\n\n        if (!delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate,\n            beforeDist,\n            beforeDelta,\n            beforeRotate,\n            transform: `${datas.transform} rotate(${dist}deg)`,\n            isPinch: !!isPinch,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<RotatableProps>, e: any) {\n        const { datas, isDrag } = e;\n\n        if (!datas.isRotate) {\n            return false;\n        }\n        datas.isRotate = false;\n\n        triggerEvent(moveable, \"onRotateEnd\", fillParams<OnRotateEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: dragControlCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas, inputEvent } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        params.set(moveable.rotation);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            { ...e, parentRotate: 0 },\n            (child, childDatas, eventParams) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                childDatas.prevClient = childClient;\n                eventParams.dragStart = Draggable.dragStart(\n                    child,\n                    new CustomDragger().dragStart(childClient, inputEvent),\n                );\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { inputEvent, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            { ...e, parentRotate },\n            (child, childDatas, result, i) => {\n                const [prevX, prevY] = childDatas.prevClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                childDatas.prevClient = [clientX, clientY];\n\n                const dragResult = Draggable.drag(\n                    child,\n                    setCustomDrag(child.state, delta, inputEvent, !!e.isPinch, false),\n                );\n                result.drag = dragResult;\n            },\n        );\n        moveable.rotation = params.beforeRotate;\n\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            set: (rotation: number) => {\n                moveable.rotation = rotation;\n            },\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnRotateGroupEnd = fillParams(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10, isInstant: true });\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distRotate = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                distRotate += e.deltaRotate;\n\n                return { datas, parentDist: distRotate };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { prefix, getControlTransform, throttle } from \"./utils\";\nimport { ResizableProps, ScalableProps, WarpableProps, Renderer } from \"./types\";\nimport { DIRECTION_INDEXES, DIRECTION_ROTATIONS, DIRECTIONS } from \"./consts\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function renderControls(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    defaultDirections: string[],\n    React: Renderer,\n): any[] {\n    const {\n        renderPoses,\n        rotation,\n    } = moveable.state;\n    const {\n        renderDirections: directions = defaultDirections,\n    } = moveable.props;\n\n    const directionMap: IObject<boolean> = {};\n    directions.forEach(direction => {\n        directionMap[direction] = true;\n    });\n    return directions.map(direction => {\n        const indexes = DIRECTION_INDEXES[direction];\n\n        if (!indexes || !directionMap[direction]) {\n            return null;\n        }\n        const directionRotation = (throttle(rotation / Math.PI * 180, 15) + DIRECTION_ROTATIONS[direction]) % 180;\n\n        return (\n            <div className={prefix(\"control\", \"direction\", direction)}\n                data-rotation={directionRotation} data-direction={direction} key={`direction-${direction}`}\n                style={getControlTransform(rotation, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\nexport function renderAllDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n) {\n    return renderControls(moveable, DIRECTIONS, React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n): any[] {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n","import {\n    throttle, getDirection, triggerEvent,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth, getCSSSize, getDistSize, caculateBoundSize,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getDragDist,\n    getResizeDist,\n    getStartDirection,\n    getAbsoluteFixedPosition,\n} from \"../DraggerUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    Renderer, OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd,\n} from \"../types\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport {\n    triggerChildAble,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapSize } from \"./Snappable\";\nimport {\n    directionCondition,\n} from \"./utils\";\nimport { IObject, isString } from \"@daybrush/utils\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n */\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    updateRect: true,\n    canPinch: true,\n    props: {\n        resizable: Boolean,\n        throttleResize: Number,\n        renderDirections: Array,\n        baseDirection: Array,\n        keepRatio: Boolean,\n    },\n    render(moveable: MoveableManager<Partial<ResizableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, edge } = moveable.props;\n        if (resizable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            isPinch,\n            parentDirection,\n            datas,\n            parentFlag,\n        } = e;\n\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n\n        const { target, width, height } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        !isPinch && setDragStart(moveable, { datas });\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n        [\n            datas.startWidth,\n            datas.startHeight,\n        ] = getCSSSize(target);\n        const padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];\n        datas.minSize = padding;\n        datas.maxSize = [Infinity, Infinity];\n\n        if (!parentFlag) {\n            const style = window.getComputedStyle(target);\n\n            datas.minSize = plus([\n                parseFloat(style.minWidth!) || 0,\n                parseFloat(style.minHeight!) || 0,\n            ], padding);\n            datas.maxSize = plus([\n                parseFloat(style.maxWidth!) || Infinity,\n                parseFloat(style.maxHeight!) || Infinity,\n            ], padding);\n        }\n        const transformOrigin = moveable.props.transformOrigin || \"% %\";\n\n        datas.transformOrigin = transformOrigin && isString(transformOrigin)\n            ? transformOrigin.split(\" \")\n            : transformOrigin;\n        datas.startDirection = getStartDirection(moveable, direction);\n        datas.fixedPosition = getAbsoluteFixedPosition(moveable, datas.startDirection);\n        datas.fixedOriginalPosition = getAbsoluteFixedPosition(moveable, direction);\n\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ),\n        });\n        const result = triggerEvent(moveable, \"onResizeStart\", params);\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            distX, distY,\n            parentFlag, isPinch,\n            parentDistance, parentScale, inputEvent,\n            parentKeepRatio,\n            dragClient,\n            parentDist,\n            isRequest,\n        } = e;\n\n        const {\n            direction,\n            isResize,\n            transformOrigin,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            startWidth,\n            startHeight,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n            minSize,\n            maxSize,\n        } = datas;\n        const {\n            throttleResize = 0,\n            parentMoveable,\n        } = moveable.props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const isWidth = sizeDirection[0] || !sizeDirection[1];\n        const ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;\n        const startDirection = keepRatio || parentFlag ? direction : datas.startDirection;\n        let fixedPosition = dragClient;\n        let distWidth: number = 0;\n        let distHeight: number = 0;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsoluteFixedPosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = (keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition);\n            }\n        }\n\n        if (parentDist) {\n            distWidth = parentDist[0];\n            distHeight = parentDist[1];\n        } else if (parentScale) {\n            distWidth = (parentScale[0] - 1) * startOffsetWidth;\n            distHeight = (parentScale[1] - 1) * startOffsetHeight;\n        } else if (isPinch) {\n            if (parentDistance) {\n                distWidth = parentDistance;\n                distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n\n            distWidth = sizeDirection[0] * dist[0];\n            distHeight = sizeDirection[1] * dist[1];\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], sizeDirection);\n                const ratioRad = getRad([0, 0], [startOffsetWidth, startOffsetHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!sizeDirection[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!sizeDirection[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n        }\n        let nextWidth = sizeDirection[0] || keepRatio\n            ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n        let nextHeight = sizeDirection[1] || keepRatio\n            ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n        if (keepRatio && startOffsetWidth && startOffsetHeight) {\n            // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n            nextHeight = nextWidth * startOffsetHeight / startOffsetWidth;\n        }\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapSize(\n                moveable, nextWidth,\n                nextHeight, direction,\n                datas.fixedOriginalPosition,\n                isRequest,\n                datas,\n            );\n        }\n        if (parentDist) {\n            !parentDist[0] && (snapDist[0] = 0);\n            !parentDist[1] && (snapDist[1] = 0);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nextWidth = throttle(nextWidth, throttleResize!);\n                } else {\n                    nextHeight = throttle(nextHeight, throttleResize!);\n                }\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nextWidth += snapDist[0];\n                nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nextHeight += snapDist[1];\n                nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);\n            }\n        } else {\n            nextWidth += snapDist[0];\n            nextHeight += snapDist[1];\n            if (!snapDist[0]) {\n                nextWidth = throttle(nextWidth, throttleResize!);\n            }\n            if (!snapDist[1]) {\n                nextHeight = throttle(nextHeight, throttleResize!);\n            }\n        }\n        [nextWidth, nextHeight] = caculateBoundSize(\n            [nextWidth, nextHeight],\n            minSize,\n            maxSize,\n            keepRatio,\n        );\n        nextWidth = Math.round(nextWidth);\n        nextHeight = Math.round(nextHeight);\n        distWidth = nextWidth - startOffsetWidth;\n        distHeight = nextHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        const inverseDelta = getResizeDist(\n                moveable,\n                nextWidth, nextHeight,\n                startDirection, fixedPosition, transformOrigin);\n\n        if (!parentMoveable && delta.every(num => !num) && inverseDelta.every(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnResize>(moveable, e, {\n            width: startWidth + distWidth,\n            height: startHeight + distHeight,\n            offsetWidth: nextWidth,\n            offsetHeight: nextHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!isPinch,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent, !!isPinch, false),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            this.dragControl(moveable, e);\n            return true;\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isResize) {\n            return false;\n        }\n        datas.isResize = false;\n\n        const params = fillParams<OnResizeEnd>(moveable, e, {\n            isDrag,\n        });\n        triggerEvent(moveable, \"onResizeEnd\", params);\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getAbsoluteFixedPosition(moveable, direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getAbsoluteFixedPosition(child, direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const {\n            offsetWidth, offsetHeight, dist,\n        } = params;\n\n        const keepRatio = moveable.props.keepRatio;\n\n        const parentScale = [\n            offsetWidth / (offsetWidth - dist[0]),\n            offsetHeight / (offsetHeight - dist[1]),\n        ];\n        const fixedPosition = getAbsoluteFixedPosition(moveable, datas.direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * parentScale[0],\n                        childDatas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentDist: null,\n                    parentScale,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                    parentKeepRatio: keepRatio,\n                };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnResizeGroupEnd = fillParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Resizable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to resize\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10, isInstant: true });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100, isInstant: true });\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100, isInstant: true });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100, isInstant: true });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100, isInstant: true });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManager<any>) {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n        const rect = moveable.getRect();\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                if (\"offsetWidth\" in e) {\n                    distWidth = e.offsetWidth - rect.offsetWidth;\n                } else if (\"deltaWidth\" in e) {\n                    distWidth += e.deltaWidth;\n                }\n                if (\"offsetHeight\" in e) {\n                    distHeight = e.offsetHeight - rect.offsetHeight;\n                } else if (\"deltaHeight\" in e) {\n                    distHeight += e.deltaHeight;\n                }\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n","import {\n    throttle, getDirection, triggerEvent, multiply2,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth, getDistSize,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport {\n    setDragStart, getDragDist,\n    getScaleDist,\n    getAbsoluteFixedPosition,\n} from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport {\n    ScalableProps, ResizableProps, OnScaleGroup, OnScaleGroupEnd,\n    Renderer, OnScaleGroupStart, DraggableProps, OnDragStart,\n    OnDrag, SnappableState, GroupableProps, OnScaleStart, OnScale, OnScaleEnd,\n} from \"../types\";\nimport {\n    triggerChildAble,\n} from \"../groupUtils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapScale } from \"./Snappable\";\nimport { isArray, IObject } from \"@daybrush/utils\";\nimport {\n    directionCondition,\n} from \"./utils\";\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n */\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        scalable: Boolean,\n        throttleScale: Number,\n        renderDirections: String,\n        keepRatio: Boolean,\n    },\n    render(moveable: MoveableManager<Partial<ResizableProps & ScalableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, scalable, edge } = moveable.props;\n        if (!resizable && scalable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n\n        const { datas, isPinch, inputEvent, parentDirection } = e;\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!isPinch) {\n            setDragStart(moveable, { datas });\n        }\n\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.width = width;\n        datas.height = height;\n        datas.startScale = [1, 1];\n        datas.fixedPosition = getAbsoluteFixedPosition(moveable, direction);\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startScale = scale;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        const {\n            datas, distX, distY,\n            parentScale,\n            parentDistance,\n            parentKeepRatio,\n            parentFlag, isPinch, inputEvent,\n            dragClient,\n            parentDist,\n            isRequest,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            width,\n            height,\n            transform,\n            isScale,\n            startScale,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const {\n            throttleScale,\n            parentMoveable,\n        } = moveable.props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const state = moveable.state;\n        const isWidth = sizeDirection[0] || !sizeDirection[1];\n        const startWidth = width * startScale[0];\n        const startHeight = height * startScale[1];\n        const ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;\n        let scaleX: number = 1;\n        let scaleY: number = 1;\n        let fixedPosition = dragClient;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsoluteFixedPosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n\n        if (parentDist) {\n            scaleX = (width + parentDist[0]) / width;\n            scaleY = (height + parentDist[1]) / height;\n        } else if (parentScale) {\n            scaleX = parentScale[0];\n            scaleY = parentScale[1];\n        } else if (isPinch) {\n            if (parentDistance) {\n                scaleX = (width + parentDistance) / width;\n                scaleY = (height + parentDistance * height / width) / height;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n            let distWidth = sizeDirection[0] * dist[0];\n            let distHeight = sizeDirection[1] * dist[1];\n\n            if (keepRatio && width && height) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], sizeDirection);\n                const ratioRad = getRad([0, 0], [startWidth, startHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!sizeDirection[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!sizeDirection[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n            scaleX = (width + distWidth) / width;\n            scaleY = (height + distHeight) / height;\n        }\n\n        scaleX = sizeDirection[0] || keepRatio ? scaleX * startScale[0] : startScale[0];\n        scaleY = sizeDirection[1] || keepRatio ? scaleY * startScale[1] : startScale[1];\n\n        if (scaleX === 0) {\n            scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (scaleY === 0) {\n            scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n\n        const nowDist = [scaleX / startScale[0], scaleY / startScale[1]];\n        let scale = [scaleX, scaleY];\n\n        if (!isPinch && moveable.props.groupable) {\n            const snapRenderInfo = state.snapRenderInfo || {};\n            const stateDirection = snapRenderInfo.direction;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = { direction, request: e.isRequest, };\n            }\n        }\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapScale(\n                moveable,\n                nowDist,\n                direction,\n                datas.fixedPosition,\n                isRequest,\n                datas,\n            );\n        }\n\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n                } else {\n                    nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n                }\n            }\n\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nowDist[0] += snapDist[0];\n                const snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);\n\n                nowDist[1] = snapHeight / height / startScale[1];\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nowDist[1] += snapDist[1];\n                const snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);\n\n                nowDist[0] = snapWidth / width / startScale[0];\n            }\n        } else {\n            nowDist[0] += snapDist[0];\n            nowDist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n            }\n            if (!snapDist[1]) {\n                nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n            }\n        }\n        if (nowDist[0] === 0) {\n            nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (nowDist[1] === 0) {\n            nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];\n        scale = multiply2(nowDist, startScale);\n\n        datas.prevDist = nowDist;\n\n        const inverseDelta = getScaleDist(moveable, delta, direction, fixedPosition);\n        if (\n            scaleX === prevDist[0] && scaleY === prevDist[1]\n            && inverseDelta.every(num => !num)\n            && !parentMoveable\n        ) {\n            return false;\n        }\n\n        const params = fillParams<OnScale>(moveable, e, {\n            scale,\n            direction,\n            dist: nowDist,\n            delta,\n            transform: `${transform} scale(${scaleX}, ${scaleY})`,\n            isPinch: !!isPinch,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent, isPinch, false),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillParams<OnScaleEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getAbsoluteFixedPosition(moveable, direction);\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getAbsoluteFixedPosition(child, direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n        const keepRatio = moveable.props.keepRatio;\n        const { scale } = params;\n        const startPos = getAbsoluteFixedPosition(moveable, datas.direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * scale[0],\n                        childDatas.originalY * scale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentDist: null,\n                    parentScale: scale,\n                    parentKeepRatio: keepRatio,\n                    dragClient: plus(startPos, [clientX, clientY]),\n                };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams = fillParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Scalable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to scale\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10, isInstant: true });\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                distWidth += e.deltaWidth;\n                distHeight += e.deltaHeight;\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n","import { prefix, getLineStyle, getDirection, getAbsolutePosesByState, triggerEvent, fillParams } from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    convertMatrixtoCSS, caculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    multiplyCSS,\n    minus,\n    createWarpMatrix,\n    getRad,\n    plus,\n} from \"@moveable/matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport { setDragStart, getDragDist, getPosIndexesByDirection } from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd,\n} from \"../types\";\nimport { hasClass, dot } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirection\";\nimport { hasGuidelines, checkSnapBounds } from \"./Snappable\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: {\n        warpable: Boolean,\n        renderDirections: Array,\n    },\n    render(moveable: MoveableManager<ResizableProps & ScalableProps & WarpableProps>, React: Renderer) {\n        const { resizable, scalable, warpable } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return;\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")} key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4)}></div>,\n            ...renderAllDirections(moveable, React),\n        ];\n    },\n    dragControlCondition(e: any) {\n        if (e.isRequest) {\n            return false;\n        }\n        return hasClass(e.inputEvent.target, prefix(\"direction\"));\n    },\n    dragControlStart(\n        moveable: MoveableManager<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n\n        setDragStart(moveable, { datas });\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map(p => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startMatrix = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n        state.snapRenderInfo = {\n            request: e.isRequest,\n            direction,\n        };\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startMatrix = matrix;\n            },\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl(\n        moveable: MoveableManager<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, isRequest } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startMatrix,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkSnapBounds(\n                moveable,\n                isRequest,\n                selectedPoses.map(pos => [pos[0] + distX, pos[1] + distY]),\n            );\n\n            distY -= horizontalSnapInfo.offset;\n            distX -= verticalSnapInfo.offset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[1],\n            poses[2],\n            poses[3],\n            nextPoses[0],\n            nextPoses[1],\n            nextPoses[2],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n\n        const matrix = convertMatrixtoCSS(multiply(targetInverseMatrix, h, 4));\n        const transform = `${datas.targetTransform} matrix3d(${matrix.join(\",\")})`;\n\n        const delta = multiplyCSS(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: multiplyCSS(startMatrix, matrix, 4),\n            multiply: multiplyCSS,\n            dist: matrix,\n            transform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManager<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillParams<OnWarpEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n};\n","import { prefix } from \"./utils\";\n\nexport const AREA = prefix(\"area\");\nexport const AREA_PIECES = prefix(\"area-pieces\");\nexport const AREA_PIECE = prefix(\"area-piece\");\nexport const AVOID = prefix(\"avoid\");\n","import MoveableManager from \"../MoveableManager\";\nimport {\n    createWarpMatrix, convertMatrixtoCSS,\n} from \"@moveable/matrix\";\nimport { ref } from \"framework-utils\";\nimport { triggerEvent, fillParams, getRect, caculateInversePosition } from \"../utils\";\nimport { Renderer, GroupableProps, DragAreaProps, OnClick, OnClickGroup } from \"../types\";\nimport { AREA_PIECE, AREA, AVOID, AREA_PIECES } from \"../classNames\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { addClass, findIndex, removeClass } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManager) {\n    const el = moveable.areaElement;\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    props: {\n        dragArea: Boolean,\n    },\n    render(moveable: MoveableManager<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable } = moveable.props;\n        const { width, height, renderPoses } = moveable.state;\n\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            renderPoses[0],\n            renderPoses[1],\n            renderPoses[2],\n            renderPoses[3],\n        );\n        const transform = h.length ? `matrix3d(${convertMatrixtoCSS(h).join(\",\")})` : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManager, { datas, clientX, clientY, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        datas.isDragArea = false;\n        datas.inputTarget = inputEvent.target;\n        const areaElement = moveable.areaElement;\n        const {\n            moveableClientRect,\n            renderPoses,\n            rootMatrix,\n            is3d,\n        } = moveable.state;\n        const { left, top } = moveableClientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n            width,\n            height,\n        } = getRect(renderPoses);\n        const n = is3d ? 4 : 3;\n        let [posX, posY] = caculateInversePosition(rootMatrix, [clientX - left, clientY - top], n);\n\n        posX -= relativeLeft;\n        posY -= relativeTop;\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n        return true;\n    },\n    drag(moveable: MoveableManager, { datas, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManager<DragAreaProps>, e: any) {\n        if (!e.inputEvent) {\n            return false;\n        }\n        const { inputEvent, datas } = e;\n        const isDragArea = datas.isDragArea;\n\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n\n        const target = moveable.state.target!;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget)) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            isDouble: e.isDouble,\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroup,\n        e: any,\n    ) {\n        const { inputEvent, isDragArea, datas } = e;\n        if (!inputEvent) {\n            return false;\n        }\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n        const prevInputTarget = datas.inputTarget;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent(moveable, \"onClickGroup\", fillParams<OnClickGroup>(moveable, e, {\n            isDouble: e.isDouble,\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { prefix, getControlTransform } from \"../utils\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"origin\",\n    props: {\n        origin: Boolean,\n    },\n    render(moveable: MoveableManager, React: Renderer): any {\n        if (!moveable.props.origin) {\n            return null;\n        }\n        const { beforeOrigin, rotation } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { ScrollableProps, OnScroll } from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: {\n        scrollable: Boolean,\n        scrollContainer: Object,\n        scrollThreshold: Number,\n    },\n    dragStart(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer(),\n        } = props;\n\n        const dragScroll = new DragScroll();\n\n        e.datas.dragScroll = dragScroll;\n\n        const draggerName = e.isControl ? \"controlDragger\" : \"targetDragger\";\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY }) => {\n            moveable[draggerName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainer as HTMLElement,\n        });\n    },\n    checkScroll(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const {\n            dragScroll,\n        } = e.datas;\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer(),\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer,\n            threshold: scrollThreshold,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManager<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManager<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart(moveable: MoveableManager<ScrollableProps>, e: any) {\n        return this.dragStart(moveable, { ...e, isControl: true });\n    },\n    dragControl(moveable: MoveableManager<ScrollableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManager<ScrollableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets, isControl: true });\n    },\n    dragGroupContro(moveable: MoveableGroup, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControEnd(moveable: MoveableGroup, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n","export default {\n    name: \"\",\n    props: {\n        target: Object,\n        container: Object,\n        dragArea: Boolean,\n        origin: Boolean,\n        transformOrigin: Array,\n        edge: Boolean,\n        ables: Array,\n        className: String,\n        pinchThreshold: Number,\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { prefix } from \"../utils\";\nimport { Renderer } from \"../types\";\nimport { createWarpMatrix, convertMatrixtoCSS } from \"@moveable/matrix\";\n\nexport default {\n    name: \"padding\",\n    props: {\n        padding: Object,\n    },\n    render(moveable: MoveableManager, React: Renderer): any {\n        const props = moveable.props;\n        if (props.dragArea) {\n            return [];\n        }\n        const padding = props.padding || {};\n        const {\n            left = 0,\n            top = 0,\n            right = 0,\n            bottom = 0,\n        } = padding;\n        const {\n            renderPoses,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        } = moveable.state;\n\n        const poses = [pos1, pos2, pos3, pos4];\n        const paddingDirections = [];\n\n        if (left > 0) {\n            paddingDirections.push([0, 2]);\n        }\n        if (top > 0) {\n            paddingDirections.push([0, 1]);\n        }\n        if (right > 0) {\n            paddingDirections.push([1, 3]);\n        }\n        if (bottom > 0) {\n            paddingDirections.push([2, 3]);\n        }\n        return paddingDirections.map(([dir1, dir2], i) => {\n            const paddingPos1 = poses[dir1];\n            const paddingPos2 = poses[dir2];\n            const paddingPos3 = renderPoses[dir1];\n            const paddingPos4 = renderPoses[dir2];\n\n            const h = createWarpMatrix(\n                [0, 0],\n                [100, 0],\n                [0, 100],\n                [100, 100],\n                paddingPos1,\n                paddingPos2,\n                paddingPos3,\n                paddingPos4,\n            );\n            if (!h.length) {\n                return undefined;\n            }\n            return (<div key={`padding${i}`} className={prefix(\"padding\")} style={{\n                transform: `matrix3d(${convertMatrixtoCSS(h).join(\",\")})`,\n            }}></div>);\n        });\n    },\n};\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\nimport Padding from \"./Padding\";\n// import Clippable from \"./Clippable\";\n\nexport const MOVEABLE_ABLES = [\n    Default, Snappable, Pinchable, Draggable, Rotatable,\n    Resizable, Scalable, Warpable, Scrollable, DragArea, Padding, Origin,\n    // Clippable,\n] as const;\n","import { refs } from \"framework-utils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    props: {\n        defaultGroupRotate: Number,\n        groupable: Boolean,\n    },\n    render(moveable: MoveableGroup, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n\n        return targets.map((target, i) => {\n            return <MoveableManager\n                key={\"moveable\" + i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        });\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, MoveableManagerProps } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleDragger, getTargetAbleDragger } from \"./getAbleDragger\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getTargetInfo, throttle, getAbsolutePosesByState, equals } from \"./utils\";\nimport { plus, rotate } from \"@moveable/matrix\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = rotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1s = [MIN_NUM, MAX_NUM];\n        const b2s = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                // ㅠ = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1s[0] = Math.max(b1s[0], b1);\n                b1s[1] = Math.min(b1s[1], b1);\n                b2s[0] = Math.max(b2s[0], b2);\n                b2s[1] = Math.min(b2s[1], b2);\n            });\n        });\n\n        b1s.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2s.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n\nclass MoveableGroup extends MoveableManager<GroupableProps, any> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public rotation: number = 0;\n\n    public updateEvent(prevProps: MoveableManagerProps<GroupableProps>) {\n        const state = this.state;\n        const props = this.props;\n\n        if (!state.target) {\n            state.target = this.areaElement;\n\n            this.controlBox.getElement().style.display = \"block\";\n            this.targetDragger = getTargetAbleDragger(this, state.target, \"Group\");\n            this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n        }\n        const isContainerChanged = !equals(prevProps.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const props = this.props;\n        const target = state.target! || props.target!;\n\n        if (!isTarget || (type !== \"\" && props.updateGroup)) {\n            // reset rotataion\n            this.rotation = props.defaultGroupRotate!;\n        }\n        const rotation = this.rotation;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        target.style.cssText += `left:0px;top:0px;width:${width}px; height:${height}px;transform:rotate(${rotation}deg)`;\n        state.width = width;\n        state.height = height;\n\n        const container = this.getContainer();\n        const info = getTargetInfo(\n            this.controlBox.getElement(),\n            target,\n            this.controlBox.getElement(),\n            this.getContainer(),\n            this.props.rootContainer || container,\n            state,\n        );\n        const pos = [info.left!, info.top!];\n        [\n            info.pos1,\n            info.pos2,\n            info.pos3,\n            info.pos4,\n        ] = getAbsolutePosesByState(info as Required<typeof info>);\n        info.origin = plus(pos, info.origin!);\n        info.beforeOrigin = plus(pos, info.beforeOrigin!);\n\n        const clientRect = info.targetClientRect!;\n\n        clientRect.top += (top - info.top!) - state.top;\n        clientRect.left += (left - info.left!) - state.left;\n\n        this.updateState(\n            {\n                ...info,\n                left: left - info.left!,\n                top: top - info.top!,\n            },\n            isSetState,\n        );\n    }\n    public triggerEvent(name: string, e: any): any {\n        if (name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n}\n\nexport default MoveableGroup;\n","import * as React from \"react\";\nimport { MoveableProps, Able, MoveableInterface, RectInfo, AbleRequestParam, Requester, HitRect } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref } from \"framework-utils\";\nimport { isArray } from \"@daybrush/utils\";\nimport Groupable from \"./ables/Groupable\";\n\nexport default class Moveable<T = {}> extends React.PureComponent<MoveableProps & T> implements MoveableInterface {\n    public moveable!: MoveableManager<MoveableProps> | MoveableGroup;\n    public render() {\n        const props = this.props;\n        const ables: Able[] = props.ables as Able[] || [];\n        const target = this.props.target || this.props.targets;\n        const isArr = isArray(target);\n        const isGroup = isArr && (target as any[]).length > 1;\n\n        if (isGroup) {\n            const nextProps = {\n                ...this.props,\n                target: null,\n                targets: target as any[],\n                ables: [...MOVEABLE_ABLES, Groupable, ...ables],\n            };\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps} />;\n        } else {\n            const moveableTarget = isArr ? (target as any[])[0] : target;\n\n            return <MoveableManager<MoveableProps> key=\"single\" ref={ref(this, \"moveable\")}\n                {...{ ...this.props, target: moveableTarget, ables: [...MOVEABLE_ABLES, ...ables] }} />;\n        }\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @method Moveable#isMoveableElement\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: HTMLElement | SVGElement): boolean {\n        return this.moveable.isMoveableElement(target);\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @method Moveable#dragStart\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent): void {\n        this.moveable.dragStart(e);\n    }\n\n    /**\n     * Whether the coordinates are inside Moveable\n     * @method Moveable#isInside\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number): boolean {\n        return this.moveable.isInside(clientX, clientY);\n    }\n    /**\n     * Hit test an element or rect on a moveable target.\n     * @method Moveable#hitTest\n     * @param - element or rect to test\n     * @return - Get hit test rate (rate > 0 is hitted)\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.hitTest(e.target) > 0) {\n     *          console.log(\"hiited\");\n     *     }\n     * });\n     */\n    public hitTest(el: Element | HitRect): number {\n        return this.moveable.hitTest(el);\n    }\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @method Moveable#updateRect\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect(): void {\n        this.moveable.updateRect();\n    }\n\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @method Moveable#updateTarget\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(): void {\n        this.moveable.updateTarget();\n    }\n    /**\n     * Check if the moveable state is being dragged.\n     * @method Moveable#isDragging\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // false\n     * console.log(moveable.isDragging());\n     *\n     * moveable.on(\"drag\", () => {\n     *   // true\n     *   console.log(moveable.isDragging());\n     * });\n     */\n    public isDragging(): boolean {\n        return this.moveable.isDragging();\n    }\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @method Moveable#getRect\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        return this.moveable.getRect();\n    }\n\n    /**\n     * Request able through a method rather than an event.\n     * At the moment of execution, requestStart is executed,\n     * and then request and requestEnd can be executed through Requester.\n     * @method Moveable#request\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n     * @param - ableName\n     * @param - request to be able params. If isInstant is true, request and requestEnd are executed immediately.\n     * @return - Able Requester. If there is no request in able, nothing will work.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10, isInstant: true });\n     *\n     * // Start move\n     * const requester = moveable.request(\"draggable\");\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.requestEnd();\n     */\n    public request(ableName: string, params?: AbleRequestParam): Requester {\n        return this.moveable.request(ableName, params);\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @method Moveable#destroy\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy(): void {\n        this.moveable.componentWillUnmount();\n    }\n}\n"],"names":["getSVGCursor","scale","degree","getCursorCSS","x1","x2","degree45","Math","round","defaultCursor","agent","getAgent","IS_WEBKIT","os","name","indexOf","browser","PREFIX","MOVEABLE_CSS","prefixCSS","map","join","NEARBY_POS","TINY_NUM","MIN_SCALE","MAX_NUM","pow","MIN_NUM","DIRECTIONS","DIRECTION_INDEXES","n","s","w","e","nw","ne","sw","se","DIRECTION_ROTATIONS","multiply2","pos1","pos2","prefix","_i","classNames","prefixNames","createIdentityMatrix3","createIdentityMatrix","getTransformMatrix","transform","isObject","value","splitBracket","split","v","parseFloat","getAbsoluteMatrix","matrix","origin","multiplies","createOriginMatrix","a","measureSVGSize","el","unit","isHorizontal","viewBox","getSVGViewBox","ownerSVGElement","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","o","i","_a","style","transformOrigin","getOffsetInfo","lastParent","isParent","body","document","target","parentElement","isEnd","position","isStatic","offsetParent","getOffsetPosInfo","container","isFixed","tagName","toLowerCase","offsetLeft","offsetTop","containerClientRect","documentElement","getBoundingClientRect","left","top","isSVG","isUndefined","hasOffset","pos","offset","getMatrixStackInfo","prevMatrix","matrixes","is3d","targetMatrix","offsetContainer","length","styleTransform","convertCSStoMatrix","matrixesLength","convertDimension","offsetPos","push","getSVGMatrix","_b","isOffsetEnd","parentClientLeft","parentClientTop","clientLeft","clientTop","scrollLeft","scrollTop","caculateMatrixStack","rootContainer","prevRootMatrix","prevN","prevTargetMatrix","rootMatrixes","isRoot3d","isSVGGraphicElement","originalContainer","allMatrix","rootMatrix","beforeMatrix","offsetMatrix","endContainer","reverse","forEach","multiply","slice","isMatrix3d","convertMatrixtoCSS","ignoreDimension","clientWidth","clientHeight","baseVal","x","y","width","height","viewBoxWidth","viewBoxHeight","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","translate","xAlign","yAlign","floor","scaleDimension","max","min","scaleMatrix","createScaleMatrix","getSVGGraphicsOffset","getBBox","bbox","caculatePosition","caculate","convertPositionMatrix","caculatePoses","getRect","poses","posesX","posesY","right","bottom","rectWidth","rectHeight","caculateRect","getSVGOffset","absoluteMatrix","rect","rectLeft","rectTop","mat","_c","prevLeft","prevTop","prevWidth","prevHeight","posOrigin","prevOrigin","minus","rectOrigin","count","inverseBeforeMatrix","invert","mat2","_d","nextLeft","nextTop","distLeft","distTop","abs","p","caculateMoveablePosition","y1","y2","x3","y3","_e","x4","y4","_f","originX","originY","center","pos1Rad","getRad","pos2Rad","direction","PI","getDistSize","vec","sqrt","getDiagonalSize","getLineStyle","rad","getControlTransform","rotation","reduce","prev","getCSSSize","window","getSize","isOffset","isBoxSizing","boxSizing","offsetWidth","offsetHeight","borderLeft","borderLeftWidth","borderRight","borderRightWidth","borderTop","borderTopWidth","borderBottom","borderBottomWidth","paddingLeft","paddingRight","paddingTop","paddingBottom","getRotationRad","getTargetInfo","moveableElement","parentContainer","state","beforeDirection","targetTransform","beforeOrigin","targetClientRect","resetClientRect","moveableClientRect","undefined","beforePos","getClientRect","pos3","pos4","scrollWidth","scrollHeight","isExtends","getDirection","direciton","getAttribute","dir","getAbsolutePoses","dist","plus","getAbsolutePosesByState","roundSign","num","throttle","throttleArray","nums","_","unset","self","getOrientationDirection","isInside","k1","k2","k3","k4","k5","k6","signs1","signs2","every","sign","fillParams","moveable","params","datas","tslib_1","clientX","clientY","inputEvent","currentTarget","triggerEvent","isManager","MoveableManager","prototype","call","pseudoElt","filterAbles","ables","methods","triggerAblesSimultaneously","enabledAbles","ableGroups","filter","able","some","method","ableGroup","getKeepRatioHeight","isWidth","ratio","getKeepRatioWidth","equals","a1","a2","selectValue","values","groupBy","arr","func","groups","groupKeys","index","groupKey","keyIndex","group","groupByMap","flat","cur","concat","maxOffset","args","sort","b","minOffset","caculateInversePosition","convertDragDist","caculatePadding","checkSize","targetSize","compareSize","isMax","size","caculateBoundSize","minSize","maxSize","keepRatio","minWidth","minHeight","maxWidth","maxHeight","triggerRenderStart","isGroup","isPinch","eventAffix","targets","props","triggerRender","triggerRenderEnd","sPinch","isDrag","triggerAble","ableType","eventOperation","eventType","isReqeust","isStart","isRequest","areaElement","eventName","conditionName","isAfter","updateRect","events","renderDatas","render","renderEvent","originalDatas","results","condition","ableName","nextDatas","isUpdate","dragger","moveables","childeMoveable","isUnmounted","forceUpdate","getTargetAbleDragger","moveableTarget","controlBox","getElement","dragArea","startFunc","eventTarget","isMoveableElement","className","getAbleDragger","dragstart","pinchstart","conditionFunctions","pinchOutside","pinchThreshold","options","Dragger","ControlBoxElement","styled","renderLine","React","key","_this","renderPoses","edge","parentPosition","propsTarget","zoom","checkUpdate","updateRenderPoses","parentLeft","parentTop","stateTarget","groupTargets","isDisplay","ref","renderAbles","parentMoveable","updateEvent","prevProps","getContainer","targetDragger","onDragStart","Element","clientRect","rectRight","rectBottom","testLeft","testRight","testTop","testBottom","rectSize","type","isTarget","isSetState","updateState","controlBoxElement","hasTargetAble","targetAbles","hasControlAble","controlAbles","dragTarget","prevTarget","prevDragArea","isTargetChanged","isUnset","controlDragger","unsetAbles","isFlag","statePos","param","isInstant","groupable","requsetAble","isDragging","request","requestEnd","ableRequester","isControl","requester","ableParam","requestStart","stateLeft","stateTop","absoluteOrigin","stateContainer","updateAbles","isChanged","callback","dragStart","pinchStart","dragControlStart","nextState","setState","Renderer","createElement","padding","getRotatiion","touches","pinchable","Boolean","Number","controlEventName","pinchAbles","canPinch","result","parentRotate","ableEvent","snapRenderInfo","pinch","pinchScale","distance","parentDistance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","setCustomDrag","delta","isConvert","move","draggableDatas","draggable","parentEvent","client","prevX","prevY","startX","startY","distX","distY","deltaX","deltaY","parentDragger","triggerChildDragger","match","childs","child","childEvent","CustomDragger","childDraggers","parentFlag","triggerChildAble","eachEvent","ableDatas","childDatas","isFunction","setDragStart","inverseMatrix","startDragBeforeDist","startDragDist","getDragDist","isBefore","getInverseDragDist","caculateTransformOrigin","prevSize","isNaN","measureRatio","getPosIndexesByDirection","indexes","getPosesByDirection","getPosByDirection","nextPoses","average","getPosByReverseDirection","getStartPos","startPos1","startPos2","startPos3","startPos4","getDist","startPos","getNextMatrix","getScaleDist","fixedPosition","nextMatrix","groupLeft","groupTop","getResizeDist","nextOrigin","getStartDirection","baseDirection","getAbsoluteFixedPosition","directionCondition","parentDirection","hasClass","getGapGuidelines","guidelines","snapThreshold","start","end","otherStart","otherEnd","totalGuidelines","otherIndex","otherType","elementGuidelines","guidelineType","element","sizes","guideline1","elementStart","elementEnd","guideline2Pos","guideline2Sizes","guideline2Element","targetStart","targetEnd","gap","canSnap","gapGuidelines","centerPos","getTotalGuidelines","containerHeight","containerWidth","snapHorizontal","snapVertical","snapGap","verticalGuidelines","horizontalGuidelines","_g","checkSnapPoses","snapCenter","customSnapThreshold","snapElement","vertical","checkSnap","horizontal","checkSnapKeepRatio","endPos","endX","endY","dx","dy","isBottom","isRight","verticalInfo","isSnap","horizontalInfo","verticalSnapInfo","horizontalSnapInfo","posInfos","isVerticalSnap","verticalGuideline","isHorizontalSnap","horizontalGuideline","horizontalPos","verticalPos","checkSnaps","isCenter","isSnapCenter","verticalNames","horizontalNames","getNearestSnapGuidelineInfo","snapInfo","guideline","posInfo","guidelineInfo","guidelineInfos","targetType","targetPoses","isVertical","posType","snapPosInfos","targetPos","snapPosInfo","getSnapInfosByDirection","snapDirection","alignPoses","getNearOffsetInfo","offsets","aSign","bSign","aOffset","bOffset","aDist","bDist","isBound","isStartLine","dot","line","cx","cy","hitTestLine","test1","test2","isSameStartLine","dots","error","centerSign","checkInnerBoundDot","threshold","checkInnerBound","bounds","innerBounds","isAllBound","isVerticalBound","isHorizontalBound","leftLine","topLine","rightLine","bottomLine","isHorizontalStart","isVerticalStart","topBoundInfo","checkLineBoundCollision","bottomBoundInfo","leftBoundInfo","rightBoundInfo","isAllVerticalBound","isAllHorizontalBound","verticalOffset","horizontalOffset","boundLine","dot1","dot2","boundDot1","boundDot2","dy1","dx1","dy2","dx2","getInnerBoundInfo","lines","multiple","sizeOffset","getInnerBoundDragInfo","getCheckSnapLines","innerBoundInfo","widthOffsetInfo","heightOffsetInfo","getCheckSnapLineDirections","lineDirections","dir1","dir2","isBoundRotate","relativePoses","boundDots","rotate","getDistPointLine","solveReverseLine","checkRotateInnerBounds","prevPoses","relativeLeft","relativeRight","relativeTop","relativeBottom","dotInfos","lineRad","lineDist","dotDist","dotRad","distRad","acos","nextRad1","nextRad2","nextRad","checkInnerBoundPoses","horizontalPoses","verticalPoses","boundMap","checkBoundPoses","checkBound","checkBoundKeepRatio","startBoundPos","endBoundPos","minPos","maxPos","boundRect","boundRotate","boundPos","r","nextPos","checkRotateBounds","relativeRad1","relativeRad2","caculateContainerPos","containerRect","clientPos","snapStart","containerLeft","containerTop","targetLeft","targetTop","elementLeft","elementTop","elementRight","elementBottom","enableSnap","hasGuidelines","snappable","solveNextOffset","solveEquation","widthOffset","heightOffset","getNextFixedPoses","fixedPos","getSnapBoundOffset","boundInfo","getSnapBound","checkSnapBoundsKeepRatio","horizontalBoundInfo","verticalBoundInfo","horizontalDist","verticalDist","checkSnapBounds","boundPoses","normalized","checkMaxBounds","fixedDirection","Infinity","directions","left_1","top_1","right_1","bottom_1","otherDirection","isCheckVertical","isCheckHorizontal","otherPos","verticalDirection","horizontalDirection","deg","nextOtherPos","getSnapBoundInfo","startDirection","endDirection","otherStartPos","otherEndPos","snapBoundInfo","otherHorizontalDist","otherHorizontalOffset","isOtherHorizontalBound","isOtherHorizontalSnap","otherVerticalDist","otherVerticalOffset","isOtherVerticalBound","isOtherVerticalSnap","getCheckSnapDirections","getSizeOffsetInfo","recheckSizeByTwoDirection","snapPos","nextWidthOffset","nextHeightOffset","nextWidth","nextHeight","checkSizeDist","getNextPoses","isWidthBound","isHeightBound","widthDist","heightDist","isGetWidthOffset","checkSnapRotate","checkSnapSize","checkSnapScale","sizeDist","snapOffset","startCheckSnapDrag","absolutePoses","checkThrottleDragRotate","throttleDragRotate","offsetX","offsetY","adjustPoses","adjustPos","prevDistY","checkSnapDrag","snapPoses","verticalSnapBoundInfo","horizontalSnapBoundInfo","verticalInnerBoundInfo","horizontalInnerBoundInfo","getSnapGuidelines","getElementGuidelineDist","elementPos","elementSize","relativePos","groupByElementGuidelines","groupInfos","groupInfo","find","groupElement","groupPos","renderElementGroup","clientSize","isDisplaySnapDigit","snapDigit","snapDistFormat","directionName","posName1","posName2","sizeName","isFirstRenderSize","j","linePos","lineSize","isRenderSize","snapSize","toFixed","renderSnapPoses","renderGuidelines","targetPos1","targetPos2","getGapGuidelinesToStart","targetSizes","guidelinePos","absGap","gapPos","aPos","bPos","gapSizes","gapGuideline","renderPos","getGapGuidelinesToEnd","renderGapGuidelines","addBoundGuidelines","verticalSnapPoses","horizontalSnapPoses","verticalBoundPos","horizontalBoundPos","verticalInnerBoundPoses","horizontalInnerBoundPoses","Array","Object","minLeft","minTop","containerPos","_h","snapInfos","snap","middle","verticalPosInfos","horizontalPosInfos","elementHorizontalGroup","elementVerticalGroup","gapVerticalGuidelines","gapHorizontalGuidelines","allGuidelines","elements","gaps","dragEnd","dragControlCondition","rotatableDragControlCondtion","dragControlEnd","dragGroupStart","dragGroupEnd","dragGroupControlStart","dragGroupControlEnd","throttleDrag","dragInfo","startTranslate","prevDist","prevBeforeDist","set","startRect","drag","dragRotateRad","cos","sin","passDeltaX","passDistX","passDeltaY","passDistY","beforeTranslate","beforeDist","beforeDelta","nextTransform","nextParams","dragGroup","setRotateStartInfo","startAbsoluteOrigin","prevDeg","prevSnapDeg","startDeg","loop","getParentDeg","moveableRect","parentDist","startRotate","absoluteDeg","getDeg","throttleRotate","prevLoop","absolutePrevSnapDeg","getRotateInfo","getPositions","rotationPosition","rotatable","String","rotationRad","externalRotate","beforeInfo","afterInfo","controlRect","rotatation","isRotate","dragControl","beforeRotate","dragGroupControlCondition","parentBeforeOrigin","eventParams","childClient","prevClient","Draggable","dragGroupControl","dragResult","distRotate","deltaRotate","renderControls","defaultDirections","directionMap","directionRotation","renderAllDirections","renderDiagonalDirections","resizable","throttleResize","renderDirections","startOffsetWidth","startOffsetHeight","startWidth","startHeight","isString","fixedOriginalPosition","setOrigin","isResize","parentScale","parentKeepRatio","dragClient","sizeDirection","distWidth","distHeight","standardRad","ratioRad","signSize","snapDist","isNoSnap","inverseDelta","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","originalX","originalY","deltaWidth","deltaHeight","scalable","throttleScale","startScale","isScale","nowDist","stateDirection","isArray","snapHeight","snapWidth","getMiddleLinePos","getTriangleRad","rad1","rad2","isValidPos","poses1","poses2","pi","warpable","linePosFrom1","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","inputTarget","warpTargetMatrix","targetInverseMatrix","startMatrix","posIndexes","isWarp","selectedPoses","nearByPoses","h","createWarpMatrix","multiplyCSS","AREA","AREA_PIECES","AREA_PIECE","AVOID","restoreStyle","removeClass","cssText","renderPieces","isDragArea","posX","posY","rects","children","nextElementSibling","addClass","containsTarget","contains","isDouble","prevInputTarget","targetIndex","findIndex","parentTarget","getDefaultScrollPosition","scrollContainer","scrollable","scrollThreshold","dragScroll","DragScroll","draggerName","on","scrollBy","checkScroll","getScrollPosition","ev","dragGroupContro","dragGroupControEnd","paddingDirections","paddingPos1","paddingPos2","paddingPos3","paddingPos4","MOVEABLE_ABLES","Default","Snappable","Pinchable","Rotatable","Resizable","Scalable","Warpable","Scrollable","DragArea","Padding","Origin","defaultGroupRotate","refs","getMaxPos","getMinPos","getGroupRect","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","tan","a2_1","b1s_1","b2s_1","b1","b2","rotatePoses","changedWidth","ChildrenDiffer","display","isContainerChanged","added","changed","removed","updateGroup","info","_super","Groupable","MoveableGroup","defaultProps","isArr","nextProps","hitTest","updateTarget","componentWillUnmount"],"mappings":"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"}