{"remainingRequest":"/home/sjd/Desktop/vue-command/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/sjd/Desktop/vue-command/src/hosted/App.vue?vue&type=style&index=0&lang=scss&","dependencies":[{"path":"/home/sjd/Desktop/vue-command/src/hosted/App.vue","mtime":1599004182895},{"path":"/home/sjd/Desktop/vue-command/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/sjd/Desktop/vue-command/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/sjd/Desktop/vue-command/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/sjd/Desktop/vue-command/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/sjd/Desktop/vue-command/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/sjd/Desktop/vue-command/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoqIHsKICBtYXJnaW46IDA7CiAgcGFkZGluZzogMDsKICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7CiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsKICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7CiAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsKICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7CiAgdXNlci1zZWxlY3Q6IG5vbmU7Cn0KYm9keSB7CiAgYmFja2dyb3VuZDogIzAwMmIzNjsKCiAgaDEsCiAgaDIsCiAgaDMgewogICAgZm9udC1mYW1pbHk6ICJJbmNvbnNvbGF0YSIsIG1vbm9zcGFjZTsKICB9CgogIHAgewogICAgY29sb3I6ICM2NTg4OGM7CiAgICBmb250LXNpemU6IDIwcHg7CiAgICBmb250LWZhbWlseTogIk1vbnRzZXJyYXQiLCBzYW5zLXNlcmlmOwogIH0KCiAgcHJlIHsKICAgIHdpZHRoOiAxMDAlOwogICAgcGFkZGluZzogMDsKICAgIG1hcmdpbi10b3A6IDFlbTsKICAgIG92ZXJmbG93OiBhdXRvOwogICAgb3ZlcmZsb3cteTogaGlkZGVuOwoKICAgIGNvZGUgewogICAgICBwYWRkaW5nOiAxMHB4OwogICAgICBjb2xvcjogIzMzMzsKICAgICAgbWFyZ2luOiA1cHg7CiAgICB9CiAgfQoKICAudnVlLWNvbW1hbmQgewogICAgLnRlcm0tYmFyIHsKICAgICAgcG9zaXRpb246IGZpeGVkOwogICAgfQoKICAgIC50ZXJtLXN0ZCB7CiAgICAgIG1hcmdpbi10b3A6IDU2cHg7CiAgICAgIGhlaWdodDogMTAwJTsKICAgIH0KICB9Cn0KOjotd2Via2l0LXNjcm9sbGJhciB7CiAgd2lkdGg6IDhweDsKfQoKOjotd2Via2l0LXNjcm9sbGJhci10cmFjayB7CiAgYmFja2dyb3VuZDogIzI1MjUyNTsKfQoKOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7CiAgYmFja2dyb3VuZDogI2YxZjFmMTsKfQoKOjotd2Via2l0LXNjcm9sbGJhci10aHVtYjpob3ZlciB7CiAgYmFja2dyb3VuZDogIzMzMzsKfQo="},{"version":3,"sources":["App.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA","file":"App.vue","sourceRoot":"src/hosted","sourcesContent":["<template>\n  <main>\n    <vue-command\n      :autocompletion-resolver=\"autocompletionResolver\"\n      :built-in=\"builtIn\"\n      :commands=\"commands\"\n      :cursor.sync=\"cursor\"\n      :history.sync=\"history\"\n      :help-timeout=\"1250\"\n      :prompt=\"prompt\"\n      :stdin.sync=\"stdin\"\n      show-help></vue-command>\n  </main>\n</template>\n\n<script>\nimport ChuckNorris from './ChuckNorris'\nimport KliehParty from './KliehParty'\nimport LoadingAnimation from './LoadingAnimation'\nimport NanoEditor from './NanoEditor'\nimport VueCommand from '../components/VueCommand'\nimport { createStdout, createStderr, createDummyStdout } from '../library'\n\nconst PROMPT = 'sjd@quantum:~$'\n\nexport default {\n  components: {\n    VueCommand\n  },\n\n  data: () => ({\n    autocompletionResolver: () => undefined,\n    builtIn: undefined,\n    commands: {\n      // Navigate to home, self and back\n      cd: undefined,\n\n      // Clear terminals history\n      clear: undefined,\n\n      // Returns the parsed object to test parsing\n      // E. g.: echo --x=\"one two three\" --y=\"one two\" --z=\"one\" --test=\"okay\" --x1 --y2 --t=ok -dash\n      echo: _ => createStdout(JSON.stringify(_, null, 2)),\n\n      // Show help\n      help: () =>\n        createStdout(`Available programms:<br><br>\n        &nbsp;cd [dir]<br>\n        &nbsp;clear<br>\n        &nbsp;echo<br>\n        &nbsp;hello-world<br>\n        &nbsp;klieh<br>\n        &nbsp;loading [--amount n] [--timeout n]<br>\n        &nbsp;nano<br>\n        &nbsp;norris<br>\n        &nbsp;pokedex pokemon --color<br>\n        &nbsp;pwd<br>\n        &nbsp;reverse text<br>\n      `),\n\n      // Return simple text\n      'hello-world': () => createStdout('Hello world'),\n\n      // Show a animation\n      klieh: () => KliehParty,\n\n      // Simulate a loading animation\n      loading: () => LoadingAnimation,\n\n      // Nano editor available in many shells\n      nano: () => NanoEditor,\n\n      // Return a Chuck Norris joke\n      norris: () => ChuckNorris,\n\n      // Return color for Pokemon Pikachu\n      pokedex: ({ color, _ }) => {\n        if (color && _[1] === 'pikachu') {\n          return createStdout('yellow')\n        }\n\n        // Return help since no match\n        return createStderr(`Usage: pokedex pokemon [option | -h]<br><br>\n\n          Example: pokedex pikachu --color\n        `)\n      },\n\n      // Show current path\n      pwd: () => undefined\n    },\n\n    // Terminal cursor position\n    cursor: 0,\n    history: [],\n    options: {\n      long: {\n        pokedex: ['color'],\n        loading: ['amount', 'timeout']\n      },\n\n      short: {\n        pokedex: ['h']\n      }\n    },\n\n    prompt: PROMPT,\n    stdin: ''\n  }),\n\n  created () {\n    this.commands.clear = () => {\n      this.history = []\n      // Push dummy Stdout to show Stdin\n      return createDummyStdout()\n    }\n\n    this.commands.cd = ({ _ }) => {\n      if ((_[1] === 'home' || _[1] === 'home/') && this.prompt === PROMPT) {\n        this.prompt = `${PROMPT}home`\n\n        return createDummyStdout()\n      }\n\n      // Navigate from home to root\n      if (\n        (_[1] === '../' || _[1] === '..') &&\n        this.prompt === `${PROMPT}home`\n      ) {\n        this.prompt = PROMPT\n\n        return createDummyStdout()\n      }\n\n      // Navigate to self\n      if (_[1] === '.' || _[1] === './' || typeof _[1] === 'undefined') {\n        return createDummyStdout()\n      }\n\n      return createStderr(`cd: ${_[1]}: No such file or directory`)\n    }\n\n    this.commands.pwd = () => {\n      // Take current prompt into account\n      if (this.prompt === 'sjd@quantum:~') {\n        return createStdout('/')\n      } else {\n        return createStdout('/home')\n      }\n    }\n\n    this.builtIn = (stdin, terminal) => {\n      // Check for application\n      if (stdin.trim().split(' ')[0] !== 'reverse') {\n        terminal.commandNotFound(stdin)\n\n        return\n      }\n\n      stdin = stdin.trim()\n      // Get second argument\n      const argument = stdin\n        .split(' ')\n        .slice(1)\n        .join(' ')\n        .replace(/\"/g, '')\n\n      // Do nothing if no argument given\n      if (!argument) {\n        return\n      }\n\n      // Reverse argument\n      this.stdin = argument\n        .split('')\n        .reverse()\n        .join('')\n    }\n\n    this.autocompletionResolver = () => {\n      // Preserve cursor position\n      const cursor = this.cursor\n\n      // Reverse concatenate autocompletable according to cursor\n      let pointer = this.cursor\n      let autocompleteableStdin = ''\n      while (this.stdin[pointer - 1] !== ' ' && pointer - 1 > 0) {\n        pointer--\n        autocompleteableStdin = `${this.stdin[pointer]}${autocompleteableStdin}`\n      }\n\n      // Divide by arguments\n      const command = this.stdin.split(' ')\n\n      // Autocompleteable is program\n      if (command.length === 1) {\n        const autocompleteableProgram = command[0]\n        // Collect all autocompletion candidates\n        const candidates = []\n        const programs = [...Object.keys(this.commands), 'reverse'].sort()\n        programs.forEach(program => {\n          if (program.startsWith(autocompleteableProgram)) {\n            candidates.push(program)\n          }\n        })\n\n        // Autocompletion resolved into multiple results\n        if (this.stdin !== '' && candidates.length > 1) {\n          this.history.push({\n            // Build table programmatically\n            render: createElement => {\n              const columns = candidates.length < 5 ? candidates.length : 4\n              const rows =\n                candidates.length < 5\n                  ? 1\n                  : Math.ceil(candidates.length / columns)\n\n              let index = 0\n              const table = []\n              for (let i = 0; i < rows; i++) {\n                const row = []\n                for (let j = 0; j < columns; j++) {\n                  row.push(createElement('td', candidates[index]))\n                  index++\n                }\n\n                table.push(createElement('tr', [row]))\n              }\n\n              return createElement('table', { style: { width: '100%' } }, [\n                table\n              ])\n            }\n          })\n        }\n\n        // Autocompletion resolved into one result\n        if (candidates.length === 1) {\n          // Mutating Stdin mutates the cursor, so we've to wait to push it to the end\n          const unwatch = this.$watch(\n            () => this.cursor,\n            () => {\n              this.cursor =\n                cursor +\n                (candidates[0].length - autocompleteableStdin.length + 0)\n\n              unwatch()\n            }\n          )\n\n          this.stdin = candidates[0]\n        }\n\n        return\n      }\n\n      // Check if option might be completed already or option is last tokens\n      if (\n        this.stdin[cursor] !== '' &&\n        this.stdin[cursor] !== ' ' &&\n        typeof this.stdin[cursor] !== 'undefined'\n      ) {\n        return\n      }\n\n      // Get the executable\n      const program = command[0]\n\n      // Check if any autocompleteable exists\n      if (\n        typeof this.options.long[program] === 'undefined' &&\n        typeof this.options.short[program] === 'undefined'\n      ) {\n        return\n      }\n\n      // Autocompleteable is long option\n      if (autocompleteableStdin.substring(0, 2) === '--') {\n        const candidates = []\n        this.options.long[program].forEach(option => {\n          // If only dashes are presents, user requests all options\n          if (\n            `--${option}`.startsWith(autocompleteableStdin) ||\n            autocompleteableStdin === '--'\n          ) {\n            candidates.push(option)\n          }\n        })\n\n        // Autocompletion resolved into one result\n        if (candidates.length === 1) {\n          const autocompleted = `${this.stdin.substring(0, pointer - 1)} --${\n            candidates[0]\n          }`\n          const rest = `${this.stdin.substring(this.cursor)}`\n\n          // Mutating Stdin mutates the cursor, so we've to wait to push it to the end\n          const unwatch = this.$watch(\n            () => this.cursor,\n            () => {\n              this.cursor =\n                cursor +\n                (candidates[0].length - autocompleteableStdin.length + 2)\n\n              unwatch()\n            }\n          )\n\n          this.stdin = `${autocompleted}${rest}`\n\n          return\n        }\n\n        // Autocompletion resolved into multiple result\n        if (autocompleteableStdin === '--' || candidates.length > 1) {\n          this.history.push({\n            // Build table programmatically\n            render: createElement => {\n              const columns = candidates.length < 5 ? candidates.length : 4\n              const rows =\n                candidates.length < 5\n                  ? 1\n                  : Math.ceil(candidates.length / columns)\n\n              let index = 0\n              const table = []\n              for (let i = 0; i < rows; i++) {\n                const row = []\n                for (let j = 0; j < columns; j++) {\n                  row.push(createElement('td', `--${candidates[index]}`))\n                  index++\n                }\n\n                table.push(createElement('tr', [row]))\n              }\n\n              return createElement('table', { style: { width: '100%' } }, [\n                table\n              ])\n            }\n          })\n        }\n\n        return\n      }\n\n      // Autocompleteable is option\n      if (autocompleteableStdin.substring(0, 1) === '-') {\n        const candidates = []\n        this.options.short[program].forEach(option => {\n          // If only one dash is present, user requests all options\n          if (\n            `-${option}`.startsWith(autocompleteableStdin) ||\n            autocompleteableStdin === '-'\n          ) {\n            candidates.push(option)\n          }\n        })\n\n        // Autocompletion resolved into one result\n        if (candidates.length === 1) {\n          const autocompleted = `${this.stdin.substring(0, pointer - 1)} -${\n            candidates[0]\n          }`\n          const rest = `${this.stdin.substring(this.cursor)}`\n\n          // Mutating Stdin mutates the cursor, so we've to wait to push it to the end\n          const unwatch = this.$watch(\n            () => this.cursor,\n            () => {\n              this.cursor =\n                cursor +\n                (candidates[0].length - autocompleteableStdin.length + 1)\n\n              unwatch()\n            }\n          )\n\n          this.stdin = `${autocompleted}${rest}`\n\n          return\n        }\n\n        // Autocompletion resolved into multiple result\n        if (autocompleteableStdin === '-' || candidates.length > 1) {\n          this.history.push({\n            // Build table programmatically\n            render: createElement => {\n              const columns = candidates.length < 5 ? candidates.length : 4\n              const rows =\n                candidates.length < 5\n                  ? 1\n                  : Math.ceil(candidates.length / columns)\n\n              let index = 0\n              const table = []\n              for (let i = 0; i < rows; i++) {\n                const row = []\n                for (let j = 0; j < columns; j++) {\n                  row.push(createElement('td', `-${candidates[index]}`))\n                  index++\n                }\n\n                table.push(createElement('tr', [row]))\n              }\n\n              return createElement('table', { style: { width: '100%' } }, [\n                table\n              ])\n            }\n          })\n        }\n      }\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\">\n* {\n  margin: 0;\n  padding: 0;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\nbody {\n  background: #002b36;\n\n  h1,\n  h2,\n  h3 {\n    font-family: \"Inconsolata\", monospace;\n  }\n\n  p {\n    color: #65888c;\n    font-size: 20px;\n    font-family: \"Montserrat\", sans-serif;\n  }\n\n  pre {\n    width: 100%;\n    padding: 0;\n    margin-top: 1em;\n    overflow: auto;\n    overflow-y: hidden;\n\n    code {\n      padding: 10px;\n      color: #333;\n      margin: 5px;\n    }\n  }\n\n  .vue-command {\n    .term-bar {\n      position: fixed;\n    }\n\n    .term-std {\n      margin-top: 56px;\n      height: 100%;\n    }\n  }\n}\n::-webkit-scrollbar {\n  width: 8px;\n}\n\n::-webkit-scrollbar-track {\n  background: #252525;\n}\n\n::-webkit-scrollbar-thumb {\n  background: #f1f1f1;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: #333;\n}\n</style>\n"]}]}