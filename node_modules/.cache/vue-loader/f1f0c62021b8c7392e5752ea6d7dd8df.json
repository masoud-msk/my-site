{"remainingRequest":"/home/sjd/Desktop/vue-command/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/sjd/Desktop/vue-command/src/hosted/App.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/sjd/Desktop/vue-command/src/hosted/App.vue","mtime":1599004182895},{"path":"/home/sjd/Desktop/vue-command/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/sjd/Desktop/vue-command/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/sjd/Desktop/vue-command/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/sjd/Desktop/vue-command/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBDaHVja05vcnJpcyBmcm9tICcuL0NodWNrTm9ycmlzJwppbXBvcnQgS2xpZWhQYXJ0eSBmcm9tICcuL0tsaWVoUGFydHknCmltcG9ydCBMb2FkaW5nQW5pbWF0aW9uIGZyb20gJy4vTG9hZGluZ0FuaW1hdGlvbicKaW1wb3J0IE5hbm9FZGl0b3IgZnJvbSAnLi9OYW5vRWRpdG9yJwppbXBvcnQgVnVlQ29tbWFuZCBmcm9tICcuLi9jb21wb25lbnRzL1Z1ZUNvbW1hbmQnCmltcG9ydCB7IGNyZWF0ZVN0ZG91dCwgY3JlYXRlU3RkZXJyLCBjcmVhdGVEdW1teVN0ZG91dCB9IGZyb20gJy4uL2xpYnJhcnknCgpjb25zdCBQUk9NUFQgPSAnc2pkQHF1YW50dW06fiQnCgpleHBvcnQgZGVmYXVsdCB7CiAgY29tcG9uZW50czogewogICAgVnVlQ29tbWFuZAogIH0sCgogIGRhdGE6ICgpID0+ICh7CiAgICBhdXRvY29tcGxldGlvblJlc29sdmVyOiAoKSA9PiB1bmRlZmluZWQsCiAgICBidWlsdEluOiB1bmRlZmluZWQsCiAgICBjb21tYW5kczogewogICAgICAvLyBOYXZpZ2F0ZSB0byBob21lLCBzZWxmIGFuZCBiYWNrCiAgICAgIGNkOiB1bmRlZmluZWQsCgogICAgICAvLyBDbGVhciB0ZXJtaW5hbHMgaGlzdG9yeQogICAgICBjbGVhcjogdW5kZWZpbmVkLAoKICAgICAgLy8gUmV0dXJucyB0aGUgcGFyc2VkIG9iamVjdCB0byB0ZXN0IHBhcnNpbmcKICAgICAgLy8gRS4gZy46IGVjaG8gLS14PSJvbmUgdHdvIHRocmVlIiAtLXk9Im9uZSB0d28iIC0tej0ib25lIiAtLXRlc3Q9Im9rYXkiIC0teDEgLS15MiAtLXQ9b2sgLWRhc2gKICAgICAgZWNobzogXyA9PiBjcmVhdGVTdGRvdXQoSlNPTi5zdHJpbmdpZnkoXywgbnVsbCwgMikpLAoKICAgICAgLy8gU2hvdyBoZWxwCiAgICAgIGhlbHA6ICgpID0+CiAgICAgICAgY3JlYXRlU3Rkb3V0KGBBdmFpbGFibGUgcHJvZ3JhbW1zOjxicj48YnI+CiAgICAgICAgJm5ic3A7Y2QgW2Rpcl08YnI+CiAgICAgICAgJm5ic3A7Y2xlYXI8YnI+CiAgICAgICAgJm5ic3A7ZWNobzxicj4KICAgICAgICAmbmJzcDtoZWxsby13b3JsZDxicj4KICAgICAgICAmbmJzcDtrbGllaDxicj4KICAgICAgICAmbmJzcDtsb2FkaW5nIFstLWFtb3VudCBuXSBbLS10aW1lb3V0IG5dPGJyPgogICAgICAgICZuYnNwO25hbm88YnI+CiAgICAgICAgJm5ic3A7bm9ycmlzPGJyPgogICAgICAgICZuYnNwO3Bva2VkZXggcG9rZW1vbiAtLWNvbG9yPGJyPgogICAgICAgICZuYnNwO3B3ZDxicj4KICAgICAgICAmbmJzcDtyZXZlcnNlIHRleHQ8YnI+CiAgICAgIGApLAoKICAgICAgLy8gUmV0dXJuIHNpbXBsZSB0ZXh0CiAgICAgICdoZWxsby13b3JsZCc6ICgpID0+IGNyZWF0ZVN0ZG91dCgnSGVsbG8gd29ybGQnKSwKCiAgICAgIC8vIFNob3cgYSBhbmltYXRpb24KICAgICAga2xpZWg6ICgpID0+IEtsaWVoUGFydHksCgogICAgICAvLyBTaW11bGF0ZSBhIGxvYWRpbmcgYW5pbWF0aW9uCiAgICAgIGxvYWRpbmc6ICgpID0+IExvYWRpbmdBbmltYXRpb24sCgogICAgICAvLyBOYW5vIGVkaXRvciBhdmFpbGFibGUgaW4gbWFueSBzaGVsbHMKICAgICAgbmFubzogKCkgPT4gTmFub0VkaXRvciwKCiAgICAgIC8vIFJldHVybiBhIENodWNrIE5vcnJpcyBqb2tlCiAgICAgIG5vcnJpczogKCkgPT4gQ2h1Y2tOb3JyaXMsCgogICAgICAvLyBSZXR1cm4gY29sb3IgZm9yIFBva2Vtb24gUGlrYWNodQogICAgICBwb2tlZGV4OiAoeyBjb2xvciwgXyB9KSA9PiB7CiAgICAgICAgaWYgKGNvbG9yICYmIF9bMV0gPT09ICdwaWthY2h1JykgewogICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0ZG91dCgneWVsbG93JykKICAgICAgICB9CgogICAgICAgIC8vIFJldHVybiBoZWxwIHNpbmNlIG5vIG1hdGNoCiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0ZGVycihgVXNhZ2U6IHBva2VkZXggcG9rZW1vbiBbb3B0aW9uIHwgLWhdPGJyPjxicj4KCiAgICAgICAgICBFeGFtcGxlOiBwb2tlZGV4IHBpa2FjaHUgLS1jb2xvcgogICAgICAgIGApCiAgICAgIH0sCgogICAgICAvLyBTaG93IGN1cnJlbnQgcGF0aAogICAgICBwd2Q6ICgpID0+IHVuZGVmaW5lZAogICAgfSwKCiAgICAvLyBUZXJtaW5hbCBjdXJzb3IgcG9zaXRpb24KICAgIGN1cnNvcjogMCwKICAgIGhpc3Rvcnk6IFtdLAogICAgb3B0aW9uczogewogICAgICBsb25nOiB7CiAgICAgICAgcG9rZWRleDogWydjb2xvciddLAogICAgICAgIGxvYWRpbmc6IFsnYW1vdW50JywgJ3RpbWVvdXQnXQogICAgICB9LAoKICAgICAgc2hvcnQ6IHsKICAgICAgICBwb2tlZGV4OiBbJ2gnXQogICAgICB9CiAgICB9LAoKICAgIHByb21wdDogUFJPTVBULAogICAgc3RkaW46ICcnCiAgfSksCgogIGNyZWF0ZWQgKCkgewogICAgdGhpcy5jb21tYW5kcy5jbGVhciA9ICgpID0+IHsKICAgICAgdGhpcy5oaXN0b3J5ID0gW10KICAgICAgLy8gUHVzaCBkdW1teSBTdGRvdXQgdG8gc2hvdyBTdGRpbgogICAgICByZXR1cm4gY3JlYXRlRHVtbXlTdGRvdXQoKQogICAgfQoKICAgIHRoaXMuY29tbWFuZHMuY2QgPSAoeyBfIH0pID0+IHsKICAgICAgaWYgKChfWzFdID09PSAnaG9tZScgfHwgX1sxXSA9PT0gJ2hvbWUvJykgJiYgdGhpcy5wcm9tcHQgPT09IFBST01QVCkgewogICAgICAgIHRoaXMucHJvbXB0ID0gYCR7UFJPTVBUfWhvbWVgCgogICAgICAgIHJldHVybiBjcmVhdGVEdW1teVN0ZG91dCgpCiAgICAgIH0KCiAgICAgIC8vIE5hdmlnYXRlIGZyb20gaG9tZSB0byByb290CiAgICAgIGlmICgKICAgICAgICAoX1sxXSA9PT0gJy4uLycgfHwgX1sxXSA9PT0gJy4uJykgJiYKICAgICAgICB0aGlzLnByb21wdCA9PT0gYCR7UFJPTVBUfWhvbWVgCiAgICAgICkgewogICAgICAgIHRoaXMucHJvbXB0ID0gUFJPTVBUCgogICAgICAgIHJldHVybiBjcmVhdGVEdW1teVN0ZG91dCgpCiAgICAgIH0KCiAgICAgIC8vIE5hdmlnYXRlIHRvIHNlbGYKICAgICAgaWYgKF9bMV0gPT09ICcuJyB8fCBfWzFdID09PSAnLi8nIHx8IHR5cGVvZiBfWzFdID09PSAndW5kZWZpbmVkJykgewogICAgICAgIHJldHVybiBjcmVhdGVEdW1teVN0ZG91dCgpCiAgICAgIH0KCiAgICAgIHJldHVybiBjcmVhdGVTdGRlcnIoYGNkOiAke19bMV19OiBObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5YCkKICAgIH0KCiAgICB0aGlzLmNvbW1hbmRzLnB3ZCA9ICgpID0+IHsKICAgICAgLy8gVGFrZSBjdXJyZW50IHByb21wdCBpbnRvIGFjY291bnQKICAgICAgaWYgKHRoaXMucHJvbXB0ID09PSAnc2pkQHF1YW50dW06ficpIHsKICAgICAgICByZXR1cm4gY3JlYXRlU3Rkb3V0KCcvJykKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gY3JlYXRlU3Rkb3V0KCcvaG9tZScpCiAgICAgIH0KICAgIH0KCiAgICB0aGlzLmJ1aWx0SW4gPSAoc3RkaW4sIHRlcm1pbmFsKSA9PiB7CiAgICAgIC8vIENoZWNrIGZvciBhcHBsaWNhdGlvbgogICAgICBpZiAoc3RkaW4udHJpbSgpLnNwbGl0KCcgJylbMF0gIT09ICdyZXZlcnNlJykgewogICAgICAgIHRlcm1pbmFsLmNvbW1hbmROb3RGb3VuZChzdGRpbikKCiAgICAgICAgcmV0dXJuCiAgICAgIH0KCiAgICAgIHN0ZGluID0gc3RkaW4udHJpbSgpCiAgICAgIC8vIEdldCBzZWNvbmQgYXJndW1lbnQKICAgICAgY29uc3QgYXJndW1lbnQgPSBzdGRpbgogICAgICAgIC5zcGxpdCgnICcpCiAgICAgICAgLnNsaWNlKDEpCiAgICAgICAgLmpvaW4oJyAnKQogICAgICAgIC5yZXBsYWNlKC8iL2csICcnKQoKICAgICAgLy8gRG8gbm90aGluZyBpZiBubyBhcmd1bWVudCBnaXZlbgogICAgICBpZiAoIWFyZ3VtZW50KSB7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KCiAgICAgIC8vIFJldmVyc2UgYXJndW1lbnQKICAgICAgdGhpcy5zdGRpbiA9IGFyZ3VtZW50CiAgICAgICAgLnNwbGl0KCcnKQogICAgICAgIC5yZXZlcnNlKCkKICAgICAgICAuam9pbignJykKICAgIH0KCiAgICB0aGlzLmF1dG9jb21wbGV0aW9uUmVzb2x2ZXIgPSAoKSA9PiB7CiAgICAgIC8vIFByZXNlcnZlIGN1cnNvciBwb3NpdGlvbgogICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmN1cnNvcgoKICAgICAgLy8gUmV2ZXJzZSBjb25jYXRlbmF0ZSBhdXRvY29tcGxldGFibGUgYWNjb3JkaW5nIHRvIGN1cnNvcgogICAgICBsZXQgcG9pbnRlciA9IHRoaXMuY3Vyc29yCiAgICAgIGxldCBhdXRvY29tcGxldGVhYmxlU3RkaW4gPSAnJwogICAgICB3aGlsZSAodGhpcy5zdGRpbltwb2ludGVyIC0gMV0gIT09ICcgJyAmJiBwb2ludGVyIC0gMSA+IDApIHsKICAgICAgICBwb2ludGVyLS0KICAgICAgICBhdXRvY29tcGxldGVhYmxlU3RkaW4gPSBgJHt0aGlzLnN0ZGluW3BvaW50ZXJdfSR7YXV0b2NvbXBsZXRlYWJsZVN0ZGlufWAKICAgICAgfQoKICAgICAgLy8gRGl2aWRlIGJ5IGFyZ3VtZW50cwogICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5zdGRpbi5zcGxpdCgnICcpCgogICAgICAvLyBBdXRvY29tcGxldGVhYmxlIGlzIHByb2dyYW0KICAgICAgaWYgKGNvbW1hbmQubGVuZ3RoID09PSAxKSB7CiAgICAgICAgY29uc3QgYXV0b2NvbXBsZXRlYWJsZVByb2dyYW0gPSBjb21tYW5kWzBdCiAgICAgICAgLy8gQ29sbGVjdCBhbGwgYXV0b2NvbXBsZXRpb24gY2FuZGlkYXRlcwogICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXQogICAgICAgIGNvbnN0IHByb2dyYW1zID0gWy4uLk9iamVjdC5rZXlzKHRoaXMuY29tbWFuZHMpLCAncmV2ZXJzZSddLnNvcnQoKQogICAgICAgIHByb2dyYW1zLmZvckVhY2gocHJvZ3JhbSA9PiB7CiAgICAgICAgICBpZiAocHJvZ3JhbS5zdGFydHNXaXRoKGF1dG9jb21wbGV0ZWFibGVQcm9ncmFtKSkgewogICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2gocHJvZ3JhbSkKICAgICAgICAgIH0KICAgICAgICB9KQoKICAgICAgICAvLyBBdXRvY29tcGxldGlvbiByZXNvbHZlZCBpbnRvIG11bHRpcGxlIHJlc3VsdHMKICAgICAgICBpZiAodGhpcy5zdGRpbiAhPT0gJycgJiYgY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7CiAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCh7CiAgICAgICAgICAgIC8vIEJ1aWxkIHRhYmxlIHByb2dyYW1tYXRpY2FsbHkKICAgICAgICAgICAgcmVuZGVyOiBjcmVhdGVFbGVtZW50ID0+IHsKICAgICAgICAgICAgICBjb25zdCBjb2x1bW5zID0gY2FuZGlkYXRlcy5sZW5ndGggPCA1ID8gY2FuZGlkYXRlcy5sZW5ndGggOiA0CiAgICAgICAgICAgICAgY29uc3Qgcm93cyA9CiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLmxlbmd0aCA8IDUKICAgICAgICAgICAgICAgICAgPyAxCiAgICAgICAgICAgICAgICAgIDogTWF0aC5jZWlsKGNhbmRpZGF0ZXMubGVuZ3RoIC8gY29sdW1ucykKCiAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMAogICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gW10KICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykgewogICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gW10KICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7CiAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKGNyZWF0ZUVsZW1lbnQoJ3RkJywgY2FuZGlkYXRlc1tpbmRleF0pKQogICAgICAgICAgICAgICAgICBpbmRleCsrCiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdGFibGUucHVzaChjcmVhdGVFbGVtZW50KCd0cicsIFtyb3ddKSkKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCd0YWJsZScsIHsgc3R5bGU6IHsgd2lkdGg6ICcxMDAlJyB9IH0sIFsKICAgICAgICAgICAgICAgIHRhYmxlCiAgICAgICAgICAgICAgXSkKICAgICAgICAgICAgfQogICAgICAgICAgfSkKICAgICAgICB9CgogICAgICAgIC8vIEF1dG9jb21wbGV0aW9uIHJlc29sdmVkIGludG8gb25lIHJlc3VsdAogICAgICAgIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgLy8gTXV0YXRpbmcgU3RkaW4gbXV0YXRlcyB0aGUgY3Vyc29yLCBzbyB3ZSd2ZSB0byB3YWl0IHRvIHB1c2ggaXQgdG8gdGhlIGVuZAogICAgICAgICAgY29uc3QgdW53YXRjaCA9IHRoaXMuJHdhdGNoKAogICAgICAgICAgICAoKSA9PiB0aGlzLmN1cnNvciwKICAgICAgICAgICAgKCkgPT4gewogICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0KICAgICAgICAgICAgICAgIGN1cnNvciArCiAgICAgICAgICAgICAgICAoY2FuZGlkYXRlc1swXS5sZW5ndGggLSBhdXRvY29tcGxldGVhYmxlU3RkaW4ubGVuZ3RoICsgMCkKCiAgICAgICAgICAgICAgdW53YXRjaCgpCiAgICAgICAgICAgIH0KICAgICAgICAgICkKCiAgICAgICAgICB0aGlzLnN0ZGluID0gY2FuZGlkYXRlc1swXQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuCiAgICAgIH0KCiAgICAgIC8vIENoZWNrIGlmIG9wdGlvbiBtaWdodCBiZSBjb21wbGV0ZWQgYWxyZWFkeSBvciBvcHRpb24gaXMgbGFzdCB0b2tlbnMKICAgICAgaWYgKAogICAgICAgIHRoaXMuc3RkaW5bY3Vyc29yXSAhPT0gJycgJiYKICAgICAgICB0aGlzLnN0ZGluW2N1cnNvcl0gIT09ICcgJyAmJgogICAgICAgIHR5cGVvZiB0aGlzLnN0ZGluW2N1cnNvcl0gIT09ICd1bmRlZmluZWQnCiAgICAgICkgewogICAgICAgIHJldHVybgogICAgICB9CgogICAgICAvLyBHZXQgdGhlIGV4ZWN1dGFibGUKICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbW1hbmRbMF0KCiAgICAgIC8vIENoZWNrIGlmIGFueSBhdXRvY29tcGxldGVhYmxlIGV4aXN0cwogICAgICBpZiAoCiAgICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5sb25nW3Byb2dyYW1dID09PSAndW5kZWZpbmVkJyAmJgogICAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMuc2hvcnRbcHJvZ3JhbV0gPT09ICd1bmRlZmluZWQnCiAgICAgICkgewogICAgICAgIHJldHVybgogICAgICB9CgogICAgICAvLyBBdXRvY29tcGxldGVhYmxlIGlzIGxvbmcgb3B0aW9uCiAgICAgIGlmIChhdXRvY29tcGxldGVhYmxlU3RkaW4uc3Vic3RyaW5nKDAsIDIpID09PSAnLS0nKSB7CiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IFtdCiAgICAgICAgdGhpcy5vcHRpb25zLmxvbmdbcHJvZ3JhbV0uZm9yRWFjaChvcHRpb24gPT4gewogICAgICAgICAgLy8gSWYgb25seSBkYXNoZXMgYXJlIHByZXNlbnRzLCB1c2VyIHJlcXVlc3RzIGFsbCBvcHRpb25zCiAgICAgICAgICBpZiAoCiAgICAgICAgICAgIGAtLSR7b3B0aW9ufWAuc3RhcnRzV2l0aChhdXRvY29tcGxldGVhYmxlU3RkaW4pIHx8CiAgICAgICAgICAgIGF1dG9jb21wbGV0ZWFibGVTdGRpbiA9PT0gJy0tJwogICAgICAgICAgKSB7CiAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChvcHRpb24pCiAgICAgICAgICB9CiAgICAgICAgfSkKCiAgICAgICAgLy8gQXV0b2NvbXBsZXRpb24gcmVzb2x2ZWQgaW50byBvbmUgcmVzdWx0CiAgICAgICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICBjb25zdCBhdXRvY29tcGxldGVkID0gYCR7dGhpcy5zdGRpbi5zdWJzdHJpbmcoMCwgcG9pbnRlciAtIDEpfSAtLSR7CiAgICAgICAgICAgIGNhbmRpZGF0ZXNbMF0KICAgICAgICAgIH1gCiAgICAgICAgICBjb25zdCByZXN0ID0gYCR7dGhpcy5zdGRpbi5zdWJzdHJpbmcodGhpcy5jdXJzb3IpfWAKCiAgICAgICAgICAvLyBNdXRhdGluZyBTdGRpbiBtdXRhdGVzIHRoZSBjdXJzb3IsIHNvIHdlJ3ZlIHRvIHdhaXQgdG8gcHVzaCBpdCB0byB0aGUgZW5kCiAgICAgICAgICBjb25zdCB1bndhdGNoID0gdGhpcy4kd2F0Y2goCiAgICAgICAgICAgICgpID0+IHRoaXMuY3Vyc29yLAogICAgICAgICAgICAoKSA9PiB7CiAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPQogICAgICAgICAgICAgICAgY3Vyc29yICsKICAgICAgICAgICAgICAgIChjYW5kaWRhdGVzWzBdLmxlbmd0aCAtIGF1dG9jb21wbGV0ZWFibGVTdGRpbi5sZW5ndGggKyAyKQoKICAgICAgICAgICAgICB1bndhdGNoKCkKICAgICAgICAgICAgfQogICAgICAgICAgKQoKICAgICAgICAgIHRoaXMuc3RkaW4gPSBgJHthdXRvY29tcGxldGVkfSR7cmVzdH1gCgogICAgICAgICAgcmV0dXJuCiAgICAgICAgfQoKICAgICAgICAvLyBBdXRvY29tcGxldGlvbiByZXNvbHZlZCBpbnRvIG11bHRpcGxlIHJlc3VsdAogICAgICAgIGlmIChhdXRvY29tcGxldGVhYmxlU3RkaW4gPT09ICctLScgfHwgY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7CiAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCh7CiAgICAgICAgICAgIC8vIEJ1aWxkIHRhYmxlIHByb2dyYW1tYXRpY2FsbHkKICAgICAgICAgICAgcmVuZGVyOiBjcmVhdGVFbGVtZW50ID0+IHsKICAgICAgICAgICAgICBjb25zdCBjb2x1bW5zID0gY2FuZGlkYXRlcy5sZW5ndGggPCA1ID8gY2FuZGlkYXRlcy5sZW5ndGggOiA0CiAgICAgICAgICAgICAgY29uc3Qgcm93cyA9CiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLmxlbmd0aCA8IDUKICAgICAgICAgICAgICAgICAgPyAxCiAgICAgICAgICAgICAgICAgIDogTWF0aC5jZWlsKGNhbmRpZGF0ZXMubGVuZ3RoIC8gY29sdW1ucykKCiAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMAogICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gW10KICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykgewogICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gW10KICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7CiAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKGNyZWF0ZUVsZW1lbnQoJ3RkJywgYC0tJHtjYW5kaWRhdGVzW2luZGV4XX1gKSkKICAgICAgICAgICAgICAgICAgaW5kZXgrKwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHRhYmxlLnB1c2goY3JlYXRlRWxlbWVudCgndHInLCBbcm93XSkpCiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgndGFibGUnLCB7IHN0eWxlOiB7IHdpZHRoOiAnMTAwJScgfSB9LCBbCiAgICAgICAgICAgICAgICB0YWJsZQogICAgICAgICAgICAgIF0pCiAgICAgICAgICAgIH0KICAgICAgICAgIH0pCiAgICAgICAgfQoKICAgICAgICByZXR1cm4KICAgICAgfQoKICAgICAgLy8gQXV0b2NvbXBsZXRlYWJsZSBpcyBvcHRpb24KICAgICAgaWYgKGF1dG9jb21wbGV0ZWFibGVTdGRpbi5zdWJzdHJpbmcoMCwgMSkgPT09ICctJykgewogICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXQogICAgICAgIHRoaXMub3B0aW9ucy5zaG9ydFtwcm9ncmFtXS5mb3JFYWNoKG9wdGlvbiA9PiB7CiAgICAgICAgICAvLyBJZiBvbmx5IG9uZSBkYXNoIGlzIHByZXNlbnQsIHVzZXIgcmVxdWVzdHMgYWxsIG9wdGlvbnMKICAgICAgICAgIGlmICgKICAgICAgICAgICAgYC0ke29wdGlvbn1gLnN0YXJ0c1dpdGgoYXV0b2NvbXBsZXRlYWJsZVN0ZGluKSB8fAogICAgICAgICAgICBhdXRvY29tcGxldGVhYmxlU3RkaW4gPT09ICctJwogICAgICAgICAgKSB7CiAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChvcHRpb24pCiAgICAgICAgICB9CiAgICAgICAgfSkKCiAgICAgICAgLy8gQXV0b2NvbXBsZXRpb24gcmVzb2x2ZWQgaW50byBvbmUgcmVzdWx0CiAgICAgICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICBjb25zdCBhdXRvY29tcGxldGVkID0gYCR7dGhpcy5zdGRpbi5zdWJzdHJpbmcoMCwgcG9pbnRlciAtIDEpfSAtJHsKICAgICAgICAgICAgY2FuZGlkYXRlc1swXQogICAgICAgICAgfWAKICAgICAgICAgIGNvbnN0IHJlc3QgPSBgJHt0aGlzLnN0ZGluLnN1YnN0cmluZyh0aGlzLmN1cnNvcil9YAoKICAgICAgICAgIC8vIE11dGF0aW5nIFN0ZGluIG11dGF0ZXMgdGhlIGN1cnNvciwgc28gd2UndmUgdG8gd2FpdCB0byBwdXNoIGl0IHRvIHRoZSBlbmQKICAgICAgICAgIGNvbnN0IHVud2F0Y2ggPSB0aGlzLiR3YXRjaCgKICAgICAgICAgICAgKCkgPT4gdGhpcy5jdXJzb3IsCiAgICAgICAgICAgICgpID0+IHsKICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9CiAgICAgICAgICAgICAgICBjdXJzb3IgKwogICAgICAgICAgICAgICAgKGNhbmRpZGF0ZXNbMF0ubGVuZ3RoIC0gYXV0b2NvbXBsZXRlYWJsZVN0ZGluLmxlbmd0aCArIDEpCgogICAgICAgICAgICAgIHVud2F0Y2goKQogICAgICAgICAgICB9CiAgICAgICAgICApCgogICAgICAgICAgdGhpcy5zdGRpbiA9IGAke2F1dG9jb21wbGV0ZWR9JHtyZXN0fWAKCiAgICAgICAgICByZXR1cm4KICAgICAgICB9CgogICAgICAgIC8vIEF1dG9jb21wbGV0aW9uIHJlc29sdmVkIGludG8gbXVsdGlwbGUgcmVzdWx0CiAgICAgICAgaWYgKGF1dG9jb21wbGV0ZWFibGVTdGRpbiA9PT0gJy0nIHx8IGNhbmRpZGF0ZXMubGVuZ3RoID4gMSkgewogICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goewogICAgICAgICAgICAvLyBCdWlsZCB0YWJsZSBwcm9ncmFtbWF0aWNhbGx5CiAgICAgICAgICAgIHJlbmRlcjogY3JlYXRlRWxlbWVudCA9PiB7CiAgICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IGNhbmRpZGF0ZXMubGVuZ3RoIDwgNSA/IGNhbmRpZGF0ZXMubGVuZ3RoIDogNAogICAgICAgICAgICAgIGNvbnN0IHJvd3MgPQogICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5sZW5ndGggPCA1CiAgICAgICAgICAgICAgICAgID8gMQogICAgICAgICAgICAgICAgICA6IE1hdGguY2VpbChjYW5kaWRhdGVzLmxlbmd0aCAvIGNvbHVtbnMpCgogICAgICAgICAgICAgIGxldCBpbmRleCA9IDAKICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IFtdCiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHsKICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IFtdCiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbnM7IGorKykgewogICAgICAgICAgICAgICAgICByb3cucHVzaChjcmVhdGVFbGVtZW50KCd0ZCcsIGAtJHtjYW5kaWRhdGVzW2luZGV4XX1gKSkKICAgICAgICAgICAgICAgICAgaW5kZXgrKwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHRhYmxlLnB1c2goY3JlYXRlRWxlbWVudCgndHInLCBbcm93XSkpCiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgndGFibGUnLCB7IHN0eWxlOiB7IHdpZHRoOiAnMTAwJScgfSB9LCBbCiAgICAgICAgICAgICAgICB0YWJsZQogICAgICAgICAgICAgIF0pCiAgICAgICAgICAgIH0KICAgICAgICAgIH0pCiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["App.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"App.vue","sourceRoot":"src/hosted","sourcesContent":["<template>\n  <main>\n    <vue-command\n      :autocompletion-resolver=\"autocompletionResolver\"\n      :built-in=\"builtIn\"\n      :commands=\"commands\"\n      :cursor.sync=\"cursor\"\n      :history.sync=\"history\"\n      :help-timeout=\"1250\"\n      :prompt=\"prompt\"\n      :stdin.sync=\"stdin\"\n      show-help></vue-command>\n  </main>\n</template>\n\n<script>\nimport ChuckNorris from './ChuckNorris'\nimport KliehParty from './KliehParty'\nimport LoadingAnimation from './LoadingAnimation'\nimport NanoEditor from './NanoEditor'\nimport VueCommand from '../components/VueCommand'\nimport { createStdout, createStderr, createDummyStdout } from '../library'\n\nconst PROMPT = 'sjd@quantum:~$'\n\nexport default {\n  components: {\n    VueCommand\n  },\n\n  data: () => ({\n    autocompletionResolver: () => undefined,\n    builtIn: undefined,\n    commands: {\n      // Navigate to home, self and back\n      cd: undefined,\n\n      // Clear terminals history\n      clear: undefined,\n\n      // Returns the parsed object to test parsing\n      // E. g.: echo --x=\"one two three\" --y=\"one two\" --z=\"one\" --test=\"okay\" --x1 --y2 --t=ok -dash\n      echo: _ => createStdout(JSON.stringify(_, null, 2)),\n\n      // Show help\n      help: () =>\n        createStdout(`Available programms:<br><br>\n        &nbsp;cd [dir]<br>\n        &nbsp;clear<br>\n        &nbsp;echo<br>\n        &nbsp;hello-world<br>\n        &nbsp;klieh<br>\n        &nbsp;loading [--amount n] [--timeout n]<br>\n        &nbsp;nano<br>\n        &nbsp;norris<br>\n        &nbsp;pokedex pokemon --color<br>\n        &nbsp;pwd<br>\n        &nbsp;reverse text<br>\n      `),\n\n      // Return simple text\n      'hello-world': () => createStdout('Hello world'),\n\n      // Show a animation\n      klieh: () => KliehParty,\n\n      // Simulate a loading animation\n      loading: () => LoadingAnimation,\n\n      // Nano editor available in many shells\n      nano: () => NanoEditor,\n\n      // Return a Chuck Norris joke\n      norris: () => ChuckNorris,\n\n      // Return color for Pokemon Pikachu\n      pokedex: ({ color, _ }) => {\n        if (color && _[1] === 'pikachu') {\n          return createStdout('yellow')\n        }\n\n        // Return help since no match\n        return createStderr(`Usage: pokedex pokemon [option | -h]<br><br>\n\n          Example: pokedex pikachu --color\n        `)\n      },\n\n      // Show current path\n      pwd: () => undefined\n    },\n\n    // Terminal cursor position\n    cursor: 0,\n    history: [],\n    options: {\n      long: {\n        pokedex: ['color'],\n        loading: ['amount', 'timeout']\n      },\n\n      short: {\n        pokedex: ['h']\n      }\n    },\n\n    prompt: PROMPT,\n    stdin: ''\n  }),\n\n  created () {\n    this.commands.clear = () => {\n      this.history = []\n      // Push dummy Stdout to show Stdin\n      return createDummyStdout()\n    }\n\n    this.commands.cd = ({ _ }) => {\n      if ((_[1] === 'home' || _[1] === 'home/') && this.prompt === PROMPT) {\n        this.prompt = `${PROMPT}home`\n\n        return createDummyStdout()\n      }\n\n      // Navigate from home to root\n      if (\n        (_[1] === '../' || _[1] === '..') &&\n        this.prompt === `${PROMPT}home`\n      ) {\n        this.prompt = PROMPT\n\n        return createDummyStdout()\n      }\n\n      // Navigate to self\n      if (_[1] === '.' || _[1] === './' || typeof _[1] === 'undefined') {\n        return createDummyStdout()\n      }\n\n      return createStderr(`cd: ${_[1]}: No such file or directory`)\n    }\n\n    this.commands.pwd = () => {\n      // Take current prompt into account\n      if (this.prompt === 'sjd@quantum:~') {\n        return createStdout('/')\n      } else {\n        return createStdout('/home')\n      }\n    }\n\n    this.builtIn = (stdin, terminal) => {\n      // Check for application\n      if (stdin.trim().split(' ')[0] !== 'reverse') {\n        terminal.commandNotFound(stdin)\n\n        return\n      }\n\n      stdin = stdin.trim()\n      // Get second argument\n      const argument = stdin\n        .split(' ')\n        .slice(1)\n        .join(' ')\n        .replace(/\"/g, '')\n\n      // Do nothing if no argument given\n      if (!argument) {\n        return\n      }\n\n      // Reverse argument\n      this.stdin = argument\n        .split('')\n        .reverse()\n        .join('')\n    }\n\n    this.autocompletionResolver = () => {\n      // Preserve cursor position\n      const cursor = this.cursor\n\n      // Reverse concatenate autocompletable according to cursor\n      let pointer = this.cursor\n      let autocompleteableStdin = ''\n      while (this.stdin[pointer - 1] !== ' ' && pointer - 1 > 0) {\n        pointer--\n        autocompleteableStdin = `${this.stdin[pointer]}${autocompleteableStdin}`\n      }\n\n      // Divide by arguments\n      const command = this.stdin.split(' ')\n\n      // Autocompleteable is program\n      if (command.length === 1) {\n        const autocompleteableProgram = command[0]\n        // Collect all autocompletion candidates\n        const candidates = []\n        const programs = [...Object.keys(this.commands), 'reverse'].sort()\n        programs.forEach(program => {\n          if (program.startsWith(autocompleteableProgram)) {\n            candidates.push(program)\n          }\n        })\n\n        // Autocompletion resolved into multiple results\n        if (this.stdin !== '' && candidates.length > 1) {\n          this.history.push({\n            // Build table programmatically\n            render: createElement => {\n              const columns = candidates.length < 5 ? candidates.length : 4\n              const rows =\n                candidates.length < 5\n                  ? 1\n                  : Math.ceil(candidates.length / columns)\n\n              let index = 0\n              const table = []\n              for (let i = 0; i < rows; i++) {\n                const row = []\n                for (let j = 0; j < columns; j++) {\n                  row.push(createElement('td', candidates[index]))\n                  index++\n                }\n\n                table.push(createElement('tr', [row]))\n              }\n\n              return createElement('table', { style: { width: '100%' } }, [\n                table\n              ])\n            }\n          })\n        }\n\n        // Autocompletion resolved into one result\n        if (candidates.length === 1) {\n          // Mutating Stdin mutates the cursor, so we've to wait to push it to the end\n          const unwatch = this.$watch(\n            () => this.cursor,\n            () => {\n              this.cursor =\n                cursor +\n                (candidates[0].length - autocompleteableStdin.length + 0)\n\n              unwatch()\n            }\n          )\n\n          this.stdin = candidates[0]\n        }\n\n        return\n      }\n\n      // Check if option might be completed already or option is last tokens\n      if (\n        this.stdin[cursor] !== '' &&\n        this.stdin[cursor] !== ' ' &&\n        typeof this.stdin[cursor] !== 'undefined'\n      ) {\n        return\n      }\n\n      // Get the executable\n      const program = command[0]\n\n      // Check if any autocompleteable exists\n      if (\n        typeof this.options.long[program] === 'undefined' &&\n        typeof this.options.short[program] === 'undefined'\n      ) {\n        return\n      }\n\n      // Autocompleteable is long option\n      if (autocompleteableStdin.substring(0, 2) === '--') {\n        const candidates = []\n        this.options.long[program].forEach(option => {\n          // If only dashes are presents, user requests all options\n          if (\n            `--${option}`.startsWith(autocompleteableStdin) ||\n            autocompleteableStdin === '--'\n          ) {\n            candidates.push(option)\n          }\n        })\n\n        // Autocompletion resolved into one result\n        if (candidates.length === 1) {\n          const autocompleted = `${this.stdin.substring(0, pointer - 1)} --${\n            candidates[0]\n          }`\n          const rest = `${this.stdin.substring(this.cursor)}`\n\n          // Mutating Stdin mutates the cursor, so we've to wait to push it to the end\n          const unwatch = this.$watch(\n            () => this.cursor,\n            () => {\n              this.cursor =\n                cursor +\n                (candidates[0].length - autocompleteableStdin.length + 2)\n\n              unwatch()\n            }\n          )\n\n          this.stdin = `${autocompleted}${rest}`\n\n          return\n        }\n\n        // Autocompletion resolved into multiple result\n        if (autocompleteableStdin === '--' || candidates.length > 1) {\n          this.history.push({\n            // Build table programmatically\n            render: createElement => {\n              const columns = candidates.length < 5 ? candidates.length : 4\n              const rows =\n                candidates.length < 5\n                  ? 1\n                  : Math.ceil(candidates.length / columns)\n\n              let index = 0\n              const table = []\n              for (let i = 0; i < rows; i++) {\n                const row = []\n                for (let j = 0; j < columns; j++) {\n                  row.push(createElement('td', `--${candidates[index]}`))\n                  index++\n                }\n\n                table.push(createElement('tr', [row]))\n              }\n\n              return createElement('table', { style: { width: '100%' } }, [\n                table\n              ])\n            }\n          })\n        }\n\n        return\n      }\n\n      // Autocompleteable is option\n      if (autocompleteableStdin.substring(0, 1) === '-') {\n        const candidates = []\n        this.options.short[program].forEach(option => {\n          // If only one dash is present, user requests all options\n          if (\n            `-${option}`.startsWith(autocompleteableStdin) ||\n            autocompleteableStdin === '-'\n          ) {\n            candidates.push(option)\n          }\n        })\n\n        // Autocompletion resolved into one result\n        if (candidates.length === 1) {\n          const autocompleted = `${this.stdin.substring(0, pointer - 1)} -${\n            candidates[0]\n          }`\n          const rest = `${this.stdin.substring(this.cursor)}`\n\n          // Mutating Stdin mutates the cursor, so we've to wait to push it to the end\n          const unwatch = this.$watch(\n            () => this.cursor,\n            () => {\n              this.cursor =\n                cursor +\n                (candidates[0].length - autocompleteableStdin.length + 1)\n\n              unwatch()\n            }\n          )\n\n          this.stdin = `${autocompleted}${rest}`\n\n          return\n        }\n\n        // Autocompletion resolved into multiple result\n        if (autocompleteableStdin === '-' || candidates.length > 1) {\n          this.history.push({\n            // Build table programmatically\n            render: createElement => {\n              const columns = candidates.length < 5 ? candidates.length : 4\n              const rows =\n                candidates.length < 5\n                  ? 1\n                  : Math.ceil(candidates.length / columns)\n\n              let index = 0\n              const table = []\n              for (let i = 0; i < rows; i++) {\n                const row = []\n                for (let j = 0; j < columns; j++) {\n                  row.push(createElement('td', `-${candidates[index]}`))\n                  index++\n                }\n\n                table.push(createElement('tr', [row]))\n              }\n\n              return createElement('table', { style: { width: '100%' } }, [\n                table\n              ])\n            }\n          })\n        }\n      }\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\">\n* {\n  margin: 0;\n  padding: 0;\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\nbody {\n  background: #002b36;\n\n  h1,\n  h2,\n  h3 {\n    font-family: \"Inconsolata\", monospace;\n  }\n\n  p {\n    color: #65888c;\n    font-size: 20px;\n    font-family: \"Montserrat\", sans-serif;\n  }\n\n  pre {\n    width: 100%;\n    padding: 0;\n    margin-top: 1em;\n    overflow: auto;\n    overflow-y: hidden;\n\n    code {\n      padding: 10px;\n      color: #333;\n      margin: 5px;\n    }\n  }\n\n  .vue-command {\n    .term-bar {\n      position: fixed;\n    }\n\n    .term-std {\n      margin-top: 56px;\n      height: 100%;\n    }\n  }\n}\n::-webkit-scrollbar {\n  width: 8px;\n}\n\n::-webkit-scrollbar-track {\n  background: #252525;\n}\n\n::-webkit-scrollbar-thumb {\n  background: #f1f1f1;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: #333;\n}\n</style>\n"]}]}