{"remainingRequest":"/home/sjd/Desktop/my-site/vue-site/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/sjd/Desktop/my-site/vue-site/src/hosted/App.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/sjd/Desktop/my-site/vue-site/src/hosted/App.vue","mtime":1599147995379},{"path":"/home/sjd/Desktop/my-site/vue-site/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/sjd/Desktop/my-site/vue-site/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/sjd/Desktop/my-site/vue-site/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/sjd/Desktop/my-site/vue-site/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBDaHVja05vcnJpcyBmcm9tICcuL0NodWNrTm9ycmlzJwppbXBvcnQgUGFydHkgZnJvbSAnLi9QYXJ0eScKaW1wb3J0IE5hbm9FZGl0b3IgZnJvbSAnLi9OYW5vRWRpdG9yJwppbXBvcnQgVnVlQ29tbWFuZCBmcm9tICcuLi9jb21wb25lbnRzL1Z1ZUNvbW1hbmQnCmltcG9ydCB7IGNyZWF0ZVN0ZG91dCwgY3JlYXRlU3RkZXJyLCBjcmVhdGVEdW1teVN0ZG91dCB9IGZyb20gJy4uL2xpYnJhcnknCgpjb25zdCBQUk9NUFQgPSAnc2pkQHF1YW50dW06fiQnCmNvbnN0IFBST01QVERJUiA9IChESVIpID0+IHsKICByZXR1cm4gYHNqZEBxdWFudHVtOn4ke0RJUn0kYAp9CgpleHBvcnQgZGVmYXVsdCB7CiAgY29tcG9uZW50czogewogICAgVnVlQ29tbWFuZAogIH0sCgogIGRhdGE6ICgpID0+ICh7CiAgICBhdXRvY29tcGxldGlvblJlc29sdmVyOiAoKSA9PiB1bmRlZmluZWQsCiAgICBidWlsdEluOiB1bmRlZmluZWQsCiAgICBjb21tYW5kczogewogICAgICAvLyBsaXN0IERpcmVjdG9yeQogICAgICBsczogdW5kZWZpbmVkLAoKICAgICAgLy8gZXhpdCB0aGUgdGVybWluYWwKICAgICAgZXhpdDogdW5kZWZpbmVkLAoKICAgICAgLy8gTmF2aWdhdGUgdG8gaG9tZSwgc2VsZiBhbmQgYmFjawogICAgICBjZDogdW5kZWZpbmVkLAoKICAgICAgLy8gQ2xlYXIgdGVybWluYWxzIGhpc3RvcnkKICAgICAgY2xlYXI6IHVuZGVmaW5lZCwKCiAgICAgIC8vIFJldHVybnMgdGhlIHBhcnNlZCBvYmplY3QgdG8gdGVzdCBwYXJzaW5nCiAgICAgIC8vIEUuIGcuOiBlY2hvIC0teD0ib25lIHR3byB0aHJlZSIgLS15PSJvbmUgdHdvIiAtLXo9Im9uZSIgLS10ZXN0PSJva2F5IiAtLXgxIC0teTIgLS10PW9rIC1kYXNoCiAgICAgIC8vIGVjaG86IChfKSA9PiBjcmVhdGVTdGRvdXQoSlNPTi5zdHJpbmdpZnkoXywgbnVsbCwgMikpLAoKICAgICAgLy8gU2hvdyBoZWxwCiAgICAgIGhlbHA6ICgpID0+CiAgICAgICAgY3JlYXRlU3Rkb3V0KGAKICAgICAgICAmbmJzcDtjZCBbZGlyXTxicj4KICAgICAgICAmbmJzcDtjbGVhcjxicj4KICAgICAgICAmbmJzcDtleGl0PGJyPgogICAgICAgICZuYnNwO2VjaG88YnI+CiAgICAgICAgJm5ic3A7c2pkPGJyPgogICAgICAgICZuYnNwO2hlbGxvLXdvcmxkPGJyPgogICAgICAgICZuYnNwO25vcnJpczxicj4KICAgICAgICAmbmJzcDtuYW5vPGJyPgogICAgICBgKSwKCiAgICAgIC8vIFJldHVybiBzaW1wbGUgdGV4dAogICAgICAnaGVsbG8td29ybGQnOiAoKSA9PiBjcmVhdGVTdGRvdXQoJ0hlbGxvIHdvcmxkJyksCgogICAgICAvLyBTaG93IGEgYW5pbWF0aW9uCiAgICAgIHNqZDogKCkgPT4gUGFydHksCgogICAgICAvLyBOYW5vIGVkaXRvciBhdmFpbGFibGUgaW4gbWFueSBzaGVsbHMKICAgICAgbmFubzogKCkgPT4gTmFub0VkaXRvciwKCiAgICAgIC8vIFJldHVybiBhIENodWNrIE5vcnJpcyBqb2tlCiAgICAgIG5vcnJpczogKCkgPT4gQ2h1Y2tOb3JyaXMsCgogICAgICAvLyBTaG93IGN1cnJlbnQgcGF0aAogICAgICBwd2Q6ICgpID0+IHVuZGVmaW5lZAogICAgfSwKCiAgICAvLyBUZXJtaW5hbCBjdXJzb3IgcG9zaXRpb24KICAgIGN1cnNvcjogMCwKICAgIGhpc3Rvcnk6IFtdLAogICAgb3B0aW9uczogewogICAgICBsb25nOiB7CiAgICAgICAgcG9rZWRleDogWydjb2xvciddLAogICAgICAgIGxvYWRpbmc6IFsnYW1vdW50JywgJ3RpbWVvdXQnXQogICAgICB9LAoKICAgICAgc2hvcnQ6IHsKICAgICAgICBwb2tlZGV4OiBbJ2gnXQogICAgICB9CiAgICB9LAoKICAgIHByb21wdDogUFJPTVBULAogICAgc3RkaW46ICcnCiAgfSksCgogIGNyZWF0ZWQgKCkgewogICAgdGhpcy5jb21tYW5kcy5leGl0ID0gKCkgPT4gewogICAgICB3aW5kb3cub3BlbignaHR0cDovL2dvb2dsZS5jb20nLCAnX3NlbGYnKQogICAgfQoKICAgIHRoaXMuY29tbWFuZHMuY2xlYXIgPSAoKSA9PiB7CiAgICAgIHRoaXMuaGlzdG9yeSA9IFtdCiAgICAgIC8vIFB1c2ggZHVtbXkgU3Rkb3V0IHRvIHNob3cgU3RkaW4KICAgICAgcmV0dXJuIGNyZWF0ZUR1bW15U3Rkb3V0KCkKICAgIH0KCiAgICB0aGlzLmNvbW1hbmRzLmxzID0gKCkgPT4gewogICAgICBpZiAodGhpcy5wcm9tcHQgPT09IFBST01QVERJUignL3Jlc3VtZScpKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0ZG91dCgnbHMgZ3JlZnRpJykKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gY3JlYXRlRHVtbXlTdGRvdXQoKQogICAgICB9CiAgICB9CgogICAgdGhpcy5jb21tYW5kcy5jZCA9ICh7IF8gfSkgPT4gewogICAgICBjb25zdCBEaXJNYWtlciA9IChfLCBEaXIpID0+IHsKICAgICAgICBpZiAoCiAgICAgICAgICAoX1sxXSA9PT0gYCR7RGlyfWAgfHwgX1sxXSA9PT0gYCR7RGlyfS9gKSAmJgogICAgICAgICAgdGhpcy5wcm9tcHQgPT09IFBST01QVAogICAgICAgICkgewogICAgICAgICAgdGhpcy5wcm9tcHQgPSBQUk9NUFRESVIoYC8ke0Rpcn1gKQoKICAgICAgICAgIHJldHVybiBjcmVhdGVEdW1teVN0ZG91dCgpCiAgICAgICAgfQoKICAgICAgICAvLyBOYXZpZ2F0ZSBmcm9tIGhvbWUgdG8gcm9vdAogICAgICAgIGlmICgKICAgICAgICAgIChfWzFdID09PSAnLi4vJyB8fCBfWzFdID09PSAnLi4nIHx8IHR5cGVvZiBfWzFdID09PSAndW5kZWZpbmVkJykgJiYKICAgICAgICAgIHRoaXMucHJvbXB0ID09PSBQUk9NUFRESVIoYC8ke0Rpcn1gKQogICAgICAgICkgewogICAgICAgICAgdGhpcy5wcm9tcHQgPSBQUk9NUFQKCiAgICAgICAgICByZXR1cm4gY3JlYXRlRHVtbXlTdGRvdXQoKQogICAgICAgIH0KCiAgICAgICAgLy8gTmF2aWdhdGUgdG8gc2VsZgogICAgICAgIGlmIChfWzFdID09PSAnLicgfHwgX1sxXSA9PT0gJy4vJykgewogICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1bW15U3Rkb3V0KCkKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0ZGVycihgY2Q6ICR7X1sxXX06IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlgKQogICAgICB9CgogICAgICBEaXJNYWtlcihfLCAnaG9tZScpCiAgICB9CgogICAgdGhpcy5jb21tYW5kcy5wd2QgPSAoKSA9PiB7CiAgICAgIC8vIFRha2UgY3VycmVudCBwcm9tcHQgaW50byBhY2NvdW50CiAgICAgIGlmICh0aGlzLnByb21wdCA9PT0gJ3NqZEBxdWFudHVtOn4nKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0ZG91dCgnLycpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0ZG91dCgnL2hvbWUnKQogICAgICB9CiAgICB9CgogICAgdGhpcy5idWlsdEluID0gKHN0ZGluLCB0ZXJtaW5hbCkgPT4gewogICAgICAvLyBDaGVjayBmb3IgYXBwbGljYXRpb24KICAgICAgaWYgKHN0ZGluLnRyaW0oKS5zcGxpdCgnICcpWzBdICE9PSAncmV2ZXJzZScpIHsKICAgICAgICB0ZXJtaW5hbC5jb21tYW5kTm90Rm91bmQoc3RkaW4pCgogICAgICAgIHJldHVybgogICAgICB9CgogICAgICBzdGRpbiA9IHN0ZGluLnRyaW0oKQogICAgICAvLyBHZXQgc2Vjb25kIGFyZ3VtZW50CiAgICAgIGNvbnN0IGFyZ3VtZW50ID0gc3RkaW4uc3BsaXQoJyAnKS5zbGljZSgxKS5qb2luKCcgJykucmVwbGFjZSgvIi9nLCAnJykKCiAgICAgIC8vIERvIG5vdGhpbmcgaWYgbm8gYXJndW1lbnQgZ2l2ZW4KICAgICAgaWYgKCFhcmd1bWVudCkgewogICAgICAgIHJldHVybgogICAgICB9CgogICAgICAvLyBSZXZlcnNlIGFyZ3VtZW50CiAgICAgIHRoaXMuc3RkaW4gPSBhcmd1bWVudC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpCiAgICB9CgogICAgdGhpcy5hdXRvY29tcGxldGlvblJlc29sdmVyID0gKCkgPT4gewogICAgICAvLyBQcmVzZXJ2ZSBjdXJzb3IgcG9zaXRpb24KICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5jdXJzb3IKCiAgICAgIC8vIFJldmVyc2UgY29uY2F0ZW5hdGUgYXV0b2NvbXBsZXRhYmxlIGFjY29yZGluZyB0byBjdXJzb3IKICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLmN1cnNvcgogICAgICBsZXQgYXV0b2NvbXBsZXRlYWJsZVN0ZGluID0gJycKICAgICAgd2hpbGUgKHRoaXMuc3RkaW5bcG9pbnRlciAtIDFdICE9PSAnICcgJiYgcG9pbnRlciAtIDEgPiAwKSB7CiAgICAgICAgcG9pbnRlci0tCiAgICAgICAgYXV0b2NvbXBsZXRlYWJsZVN0ZGluID0gYCR7dGhpcy5zdGRpbltwb2ludGVyXX0ke2F1dG9jb21wbGV0ZWFibGVTdGRpbn1gCiAgICAgIH0KCiAgICAgIC8vIERpdmlkZSBieSBhcmd1bWVudHMKICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuc3RkaW4uc3BsaXQoJyAnKQoKICAgICAgLy8gQXV0b2NvbXBsZXRlYWJsZSBpcyBwcm9ncmFtCiAgICAgIGlmIChjb21tYW5kLmxlbmd0aCA9PT0gMSkgewogICAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZWFibGVQcm9ncmFtID0gY29tbWFuZFswXQogICAgICAgIC8vIENvbGxlY3QgYWxsIGF1dG9jb21wbGV0aW9uIGNhbmRpZGF0ZXMKICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gW10KICAgICAgICBjb25zdCBwcm9ncmFtcyA9IFsuLi5PYmplY3Qua2V5cyh0aGlzLmNvbW1hbmRzKSwgJ3JldmVyc2UnXS5zb3J0KCkKICAgICAgICBwcm9ncmFtcy5mb3JFYWNoKChwcm9ncmFtKSA9PiB7CiAgICAgICAgICBpZiAocHJvZ3JhbS5zdGFydHNXaXRoKGF1dG9jb21wbGV0ZWFibGVQcm9ncmFtKSkgewogICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2gocHJvZ3JhbSkKICAgICAgICAgIH0KICAgICAgICB9KQoKICAgICAgICAvLyBBdXRvY29tcGxldGlvbiByZXNvbHZlZCBpbnRvIG11bHRpcGxlIHJlc3VsdHMKICAgICAgICBpZiAodGhpcy5zdGRpbiAhPT0gJycgJiYgY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7CiAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCh7CiAgICAgICAgICAgIC8vIEJ1aWxkIHRhYmxlIHByb2dyYW1tYXRpY2FsbHkKICAgICAgICAgICAgcmVuZGVyOiAoY3JlYXRlRWxlbWVudCkgPT4gewogICAgICAgICAgICAgIGNvbnN0IGNvbHVtbnMgPSBjYW5kaWRhdGVzLmxlbmd0aCA8IDUgPyBjYW5kaWRhdGVzLmxlbmd0aCA6IDQKICAgICAgICAgICAgICBjb25zdCByb3dzID0KICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMubGVuZ3RoIDwgNQogICAgICAgICAgICAgICAgICA/IDEKICAgICAgICAgICAgICAgICAgOiBNYXRoLmNlaWwoY2FuZGlkYXRlcy5sZW5ndGggLyBjb2x1bW5zKQoKICAgICAgICAgICAgICBsZXQgaW5kZXggPSAwCiAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBbXQogICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBbXQogICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHsKICAgICAgICAgICAgICAgICAgcm93LnB1c2goY3JlYXRlRWxlbWVudCgndGQnLCBjYW5kaWRhdGVzW2luZGV4XSkpCiAgICAgICAgICAgICAgICAgIGluZGV4KysKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB0YWJsZS5wdXNoKGNyZWF0ZUVsZW1lbnQoJ3RyJywgW3Jvd10pKQogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywgeyBzdHlsZTogeyB3aWR0aDogJzEwMCUnIH0gfSwgWwogICAgICAgICAgICAgICAgdGFibGUKICAgICAgICAgICAgICBdKQogICAgICAgICAgICB9CiAgICAgICAgICB9KQogICAgICAgIH0KCiAgICAgICAgLy8gQXV0b2NvbXBsZXRpb24gcmVzb2x2ZWQgaW50byBvbmUgcmVzdWx0CiAgICAgICAgaWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09PSAxKSB7CiAgICAgICAgICAvLyBNdXRhdGluZyBTdGRpbiBtdXRhdGVzIHRoZSBjdXJzb3IsIHNvIHdlJ3ZlIHRvIHdhaXQgdG8gcHVzaCBpdCB0byB0aGUgZW5kCiAgICAgICAgICBjb25zdCB1bndhdGNoID0gdGhpcy4kd2F0Y2goCiAgICAgICAgICAgICgpID0+IHRoaXMuY3Vyc29yLAogICAgICAgICAgICAoKSA9PiB7CiAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPQogICAgICAgICAgICAgICAgY3Vyc29yICsKICAgICAgICAgICAgICAgIChjYW5kaWRhdGVzWzBdLmxlbmd0aCAtIGF1dG9jb21wbGV0ZWFibGVTdGRpbi5sZW5ndGggKyAwKQoKICAgICAgICAgICAgICB1bndhdGNoKCkKICAgICAgICAgICAgfQogICAgICAgICAgKQoKICAgICAgICAgIHRoaXMuc3RkaW4gPSBjYW5kaWRhdGVzWzBdCiAgICAgICAgfQoKICAgICAgICByZXR1cm4KICAgICAgfQoKICAgICAgLy8gQ2hlY2sgaWYgb3B0aW9uIG1pZ2h0IGJlIGNvbXBsZXRlZCBhbHJlYWR5IG9yIG9wdGlvbiBpcyBsYXN0IHRva2VucwogICAgICBpZiAoCiAgICAgICAgdGhpcy5zdGRpbltjdXJzb3JdICE9PSAnJyAmJgogICAgICAgIHRoaXMuc3RkaW5bY3Vyc29yXSAhPT0gJyAnICYmCiAgICAgICAgdHlwZW9mIHRoaXMuc3RkaW5bY3Vyc29yXSAhPT0gJ3VuZGVmaW5lZCcKICAgICAgKSB7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KCiAgICAgIC8vIEdldCB0aGUgZXhlY3V0YWJsZQogICAgICBjb25zdCBwcm9ncmFtID0gY29tbWFuZFswXQoKICAgICAgLy8gQ2hlY2sgaWYgYW55IGF1dG9jb21wbGV0ZWFibGUgZXhpc3RzCiAgICAgIGlmICgKICAgICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmxvbmdbcHJvZ3JhbV0gPT09ICd1bmRlZmluZWQnICYmCiAgICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5zaG9ydFtwcm9ncmFtXSA9PT0gJ3VuZGVmaW5lZCcKICAgICAgKSB7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KCiAgICAgIC8vIEF1dG9jb21wbGV0ZWFibGUgaXMgbG9uZyBvcHRpb24KICAgICAgaWYgKGF1dG9jb21wbGV0ZWFibGVTdGRpbi5zdWJzdHJpbmcoMCwgMikgPT09ICctLScpIHsKICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gW10KICAgICAgICB0aGlzLm9wdGlvbnMubG9uZ1twcm9ncmFtXS5mb3JFYWNoKChvcHRpb24pID0+IHsKICAgICAgICAgIC8vIElmIG9ubHkgZGFzaGVzIGFyZSBwcmVzZW50cywgdXNlciByZXF1ZXN0cyBhbGwgb3B0aW9ucwogICAgICAgICAgaWYgKAogICAgICAgICAgICBgLS0ke29wdGlvbn1gLnN0YXJ0c1dpdGgoYXV0b2NvbXBsZXRlYWJsZVN0ZGluKSB8fAogICAgICAgICAgICBhdXRvY29tcGxldGVhYmxlU3RkaW4gPT09ICctLScKICAgICAgICAgICkgewogICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2gob3B0aW9uKQogICAgICAgICAgfQogICAgICAgIH0pCgogICAgICAgIC8vIEF1dG9jb21wbGV0aW9uIHJlc29sdmVkIGludG8gb25lIHJlc3VsdAogICAgICAgIGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMSkgewogICAgICAgICAgY29uc3QgYXV0b2NvbXBsZXRlZCA9IGAke3RoaXMuc3RkaW4uc3Vic3RyaW5nKDAsIHBvaW50ZXIgLSAxKX0gLS0kewogICAgICAgICAgICBjYW5kaWRhdGVzWzBdCiAgICAgICAgICB9YAogICAgICAgICAgY29uc3QgcmVzdCA9IGAke3RoaXMuc3RkaW4uc3Vic3RyaW5nKHRoaXMuY3Vyc29yKX1gCgogICAgICAgICAgLy8gTXV0YXRpbmcgU3RkaW4gbXV0YXRlcyB0aGUgY3Vyc29yLCBzbyB3ZSd2ZSB0byB3YWl0IHRvIHB1c2ggaXQgdG8gdGhlIGVuZAogICAgICAgICAgY29uc3QgdW53YXRjaCA9IHRoaXMuJHdhdGNoKAogICAgICAgICAgICAoKSA9PiB0aGlzLmN1cnNvciwKICAgICAgICAgICAgKCkgPT4gewogICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0KICAgICAgICAgICAgICAgIGN1cnNvciArCiAgICAgICAgICAgICAgICAoY2FuZGlkYXRlc1swXS5sZW5ndGggLSBhdXRvY29tcGxldGVhYmxlU3RkaW4ubGVuZ3RoICsgMikKCiAgICAgICAgICAgICAgdW53YXRjaCgpCiAgICAgICAgICAgIH0KICAgICAgICAgICkKCiAgICAgICAgICB0aGlzLnN0ZGluID0gYCR7YXV0b2NvbXBsZXRlZH0ke3Jlc3R9YAoKICAgICAgICAgIHJldHVybgogICAgICAgIH0KCiAgICAgICAgLy8gQXV0b2NvbXBsZXRpb24gcmVzb2x2ZWQgaW50byBtdWx0aXBsZSByZXN1bHQKICAgICAgICBpZiAoYXV0b2NvbXBsZXRlYWJsZVN0ZGluID09PSAnLS0nIHx8IGNhbmRpZGF0ZXMubGVuZ3RoID4gMSkgewogICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goewogICAgICAgICAgICAvLyBCdWlsZCB0YWJsZSBwcm9ncmFtbWF0aWNhbGx5CiAgICAgICAgICAgIHJlbmRlcjogKGNyZWF0ZUVsZW1lbnQpID0+IHsKICAgICAgICAgICAgICBjb25zdCBjb2x1bW5zID0gY2FuZGlkYXRlcy5sZW5ndGggPCA1ID8gY2FuZGlkYXRlcy5sZW5ndGggOiA0CiAgICAgICAgICAgICAgY29uc3Qgcm93cyA9CiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLmxlbmd0aCA8IDUKICAgICAgICAgICAgICAgICAgPyAxCiAgICAgICAgICAgICAgICAgIDogTWF0aC5jZWlsKGNhbmRpZGF0ZXMubGVuZ3RoIC8gY29sdW1ucykKCiAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMAogICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gW10KICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykgewogICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gW10KICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7CiAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKGNyZWF0ZUVsZW1lbnQoJ3RkJywgYC0tJHtjYW5kaWRhdGVzW2luZGV4XX1gKSkKICAgICAgICAgICAgICAgICAgaW5kZXgrKwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHRhYmxlLnB1c2goY3JlYXRlRWxlbWVudCgndHInLCBbcm93XSkpCiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgndGFibGUnLCB7IHN0eWxlOiB7IHdpZHRoOiAnMTAwJScgfSB9LCBbCiAgICAgICAgICAgICAgICB0YWJsZQogICAgICAgICAgICAgIF0pCiAgICAgICAgICAgIH0KICAgICAgICAgIH0pCiAgICAgICAgfQoKICAgICAgICByZXR1cm4KICAgICAgfQoKICAgICAgLy8gQXV0b2NvbXBsZXRlYWJsZSBpcyBvcHRpb24KICAgICAgaWYgKGF1dG9jb21wbGV0ZWFibGVTdGRpbi5zdWJzdHJpbmcoMCwgMSkgPT09ICctJykgewogICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXQogICAgICAgIHRoaXMub3B0aW9ucy5zaG9ydFtwcm9ncmFtXS5mb3JFYWNoKChvcHRpb24pID0+IHsKICAgICAgICAgIC8vIElmIG9ubHkgb25lIGRhc2ggaXMgcHJlc2VudCwgdXNlciByZXF1ZXN0cyBhbGwgb3B0aW9ucwogICAgICAgICAgaWYgKAogICAgICAgICAgICBgLSR7b3B0aW9ufWAuc3RhcnRzV2l0aChhdXRvY29tcGxldGVhYmxlU3RkaW4pIHx8CiAgICAgICAgICAgIGF1dG9jb21wbGV0ZWFibGVTdGRpbiA9PT0gJy0nCiAgICAgICAgICApIHsKICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKG9wdGlvbikKICAgICAgICAgIH0KICAgICAgICB9KQoKICAgICAgICAvLyBBdXRvY29tcGxldGlvbiByZXNvbHZlZCBpbnRvIG9uZSByZXN1bHQKICAgICAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDEpIHsKICAgICAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZWQgPSBgJHt0aGlzLnN0ZGluLnN1YnN0cmluZygwLCBwb2ludGVyIC0gMSl9IC0kewogICAgICAgICAgICBjYW5kaWRhdGVzWzBdCiAgICAgICAgICB9YAogICAgICAgICAgY29uc3QgcmVzdCA9IGAke3RoaXMuc3RkaW4uc3Vic3RyaW5nKHRoaXMuY3Vyc29yKX1gCgogICAgICAgICAgLy8gTXV0YXRpbmcgU3RkaW4gbXV0YXRlcyB0aGUgY3Vyc29yLCBzbyB3ZSd2ZSB0byB3YWl0IHRvIHB1c2ggaXQgdG8gdGhlIGVuZAogICAgICAgICAgY29uc3QgdW53YXRjaCA9IHRoaXMuJHdhdGNoKAogICAgICAgICAgICAoKSA9PiB0aGlzLmN1cnNvciwKICAgICAgICAgICAgKCkgPT4gewogICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0KICAgICAgICAgICAgICAgIGN1cnNvciArCiAgICAgICAgICAgICAgICAoY2FuZGlkYXRlc1swXS5sZW5ndGggLSBhdXRvY29tcGxldGVhYmxlU3RkaW4ubGVuZ3RoICsgMSkKCiAgICAgICAgICAgICAgdW53YXRjaCgpCiAgICAgICAgICAgIH0KICAgICAgICAgICkKCiAgICAgICAgICB0aGlzLnN0ZGluID0gYCR7YXV0b2NvbXBsZXRlZH0ke3Jlc3R9YAoKICAgICAgICAgIHJldHVybgogICAgICAgIH0KCiAgICAgICAgLy8gQXV0b2NvbXBsZXRpb24gcmVzb2x2ZWQgaW50byBtdWx0aXBsZSByZXN1bHQKICAgICAgICBpZiAoYXV0b2NvbXBsZXRlYWJsZVN0ZGluID09PSAnLScgfHwgY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7CiAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCh7CiAgICAgICAgICAgIC8vIEJ1aWxkIHRhYmxlIHByb2dyYW1tYXRpY2FsbHkKICAgICAgICAgICAgcmVuZGVyOiAoY3JlYXRlRWxlbWVudCkgPT4gewogICAgICAgICAgICAgIGNvbnN0IGNvbHVtbnMgPSBjYW5kaWRhdGVzLmxlbmd0aCA8IDUgPyBjYW5kaWRhdGVzLmxlbmd0aCA6IDQKICAgICAgICAgICAgICBjb25zdCByb3dzID0KICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMubGVuZ3RoIDwgNQogICAgICAgICAgICAgICAgICA/IDEKICAgICAgICAgICAgICAgICAgOiBNYXRoLmNlaWwoY2FuZGlkYXRlcy5sZW5ndGggLyBjb2x1bW5zKQoKICAgICAgICAgICAgICBsZXQgaW5kZXggPSAwCiAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBbXQogICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCByb3cgPSBbXQogICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHsKICAgICAgICAgICAgICAgICAgcm93LnB1c2goY3JlYXRlRWxlbWVudCgndGQnLCBgLSR7Y2FuZGlkYXRlc1tpbmRleF19YCkpCiAgICAgICAgICAgICAgICAgIGluZGV4KysKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB0YWJsZS5wdXNoKGNyZWF0ZUVsZW1lbnQoJ3RyJywgW3Jvd10pKQogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywgeyBzdHlsZTogeyB3aWR0aDogJzEwMCUnIH0gfSwgWwogICAgICAgICAgICAgICAgdGFibGUKICAgICAgICAgICAgICBdKQogICAgICAgICAgICB9CiAgICAgICAgICB9KQogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KfQo="},{"version":3,"sources":["App.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"App.vue","sourceRoot":"src/hosted","sourcesContent":["<template>\n  <main>\n    <vue-command\n      :autocompletion-resolver=\"autocompletionResolver\"\n      :built-in=\"builtIn\"\n      :commands=\"commands\"\n      :cursor.sync=\"cursor\"\n      :history.sync=\"history\"\n      :help-timeout=\"1250\"\n      :prompt=\"prompt\"\n      :stdin.sync=\"stdin\"\n      show-help></vue-command>\n  </main>\n</template>\n\n<script>\nimport ChuckNorris from './ChuckNorris'\nimport Party from './Party'\nimport NanoEditor from './NanoEditor'\nimport VueCommand from '../components/VueCommand'\nimport { createStdout, createStderr, createDummyStdout } from '../library'\n\nconst PROMPT = 'sjd@quantum:~$'\nconst PROMPTDIR = (DIR) => {\n  return `sjd@quantum:~${DIR}$`\n}\n\nexport default {\n  components: {\n    VueCommand\n  },\n\n  data: () => ({\n    autocompletionResolver: () => undefined,\n    builtIn: undefined,\n    commands: {\n      // list Directory\n      ls: undefined,\n\n      // exit the terminal\n      exit: undefined,\n\n      // Navigate to home, self and back\n      cd: undefined,\n\n      // Clear terminals history\n      clear: undefined,\n\n      // Returns the parsed object to test parsing\n      // E. g.: echo --x=\"one two three\" --y=\"one two\" --z=\"one\" --test=\"okay\" --x1 --y2 --t=ok -dash\n      // echo: (_) => createStdout(JSON.stringify(_, null, 2)),\n\n      // Show help\n      help: () =>\n        createStdout(`\n        &nbsp;cd [dir]<br>\n        &nbsp;clear<br>\n        &nbsp;exit<br>\n        &nbsp;echo<br>\n        &nbsp;sjd<br>\n        &nbsp;hello-world<br>\n        &nbsp;norris<br>\n        &nbsp;nano<br>\n      `),\n\n      // Return simple text\n      'hello-world': () => createStdout('Hello world'),\n\n      // Show a animation\n      sjd: () => Party,\n\n      // Nano editor available in many shells\n      nano: () => NanoEditor,\n\n      // Return a Chuck Norris joke\n      norris: () => ChuckNorris,\n\n      // Show current path\n      pwd: () => undefined\n    },\n\n    // Terminal cursor position\n    cursor: 0,\n    history: [],\n    options: {\n      long: {\n        pokedex: ['color'],\n        loading: ['amount', 'timeout']\n      },\n\n      short: {\n        pokedex: ['h']\n      }\n    },\n\n    prompt: PROMPT,\n    stdin: ''\n  }),\n\n  created () {\n    this.commands.exit = () => {\n      window.open('http://google.com', '_self')\n    }\n\n    this.commands.clear = () => {\n      this.history = []\n      // Push dummy Stdout to show Stdin\n      return createDummyStdout()\n    }\n\n    this.commands.ls = () => {\n      if (this.prompt === PROMPTDIR('/resume')) {\n        return createStdout('ls grefti')\n      } else {\n        return createDummyStdout()\n      }\n    }\n\n    this.commands.cd = ({ _ }) => {\n      const DirMaker = (_, Dir) => {\n        if (\n          (_[1] === `${Dir}` || _[1] === `${Dir}/`) &&\n          this.prompt === PROMPT\n        ) {\n          this.prompt = PROMPTDIR(`/${Dir}`)\n\n          return createDummyStdout()\n        }\n\n        // Navigate from home to root\n        if (\n          (_[1] === '../' || _[1] === '..' || typeof _[1] === 'undefined') &&\n          this.prompt === PROMPTDIR(`/${Dir}`)\n        ) {\n          this.prompt = PROMPT\n\n          return createDummyStdout()\n        }\n\n        // Navigate to self\n        if (_[1] === '.' || _[1] === './') {\n          return createDummyStdout()\n        }\n        return createStderr(`cd: ${_[1]}: No such file or directory`)\n      }\n\n      DirMaker(_, 'home')\n    }\n\n    this.commands.pwd = () => {\n      // Take current prompt into account\n      if (this.prompt === 'sjd@quantum:~') {\n        return createStdout('/')\n      } else {\n        return createStdout('/home')\n      }\n    }\n\n    this.builtIn = (stdin, terminal) => {\n      // Check for application\n      if (stdin.trim().split(' ')[0] !== 'reverse') {\n        terminal.commandNotFound(stdin)\n\n        return\n      }\n\n      stdin = stdin.trim()\n      // Get second argument\n      const argument = stdin.split(' ').slice(1).join(' ').replace(/\"/g, '')\n\n      // Do nothing if no argument given\n      if (!argument) {\n        return\n      }\n\n      // Reverse argument\n      this.stdin = argument.split('').reverse().join('')\n    }\n\n    this.autocompletionResolver = () => {\n      // Preserve cursor position\n      const cursor = this.cursor\n\n      // Reverse concatenate autocompletable according to cursor\n      let pointer = this.cursor\n      let autocompleteableStdin = ''\n      while (this.stdin[pointer - 1] !== ' ' && pointer - 1 > 0) {\n        pointer--\n        autocompleteableStdin = `${this.stdin[pointer]}${autocompleteableStdin}`\n      }\n\n      // Divide by arguments\n      const command = this.stdin.split(' ')\n\n      // Autocompleteable is program\n      if (command.length === 1) {\n        const autocompleteableProgram = command[0]\n        // Collect all autocompletion candidates\n        const candidates = []\n        const programs = [...Object.keys(this.commands), 'reverse'].sort()\n        programs.forEach((program) => {\n          if (program.startsWith(autocompleteableProgram)) {\n            candidates.push(program)\n          }\n        })\n\n        // Autocompletion resolved into multiple results\n        if (this.stdin !== '' && candidates.length > 1) {\n          this.history.push({\n            // Build table programmatically\n            render: (createElement) => {\n              const columns = candidates.length < 5 ? candidates.length : 4\n              const rows =\n                candidates.length < 5\n                  ? 1\n                  : Math.ceil(candidates.length / columns)\n\n              let index = 0\n              const table = []\n              for (let i = 0; i < rows; i++) {\n                const row = []\n                for (let j = 0; j < columns; j++) {\n                  row.push(createElement('td', candidates[index]))\n                  index++\n                }\n\n                table.push(createElement('tr', [row]))\n              }\n\n              return createElement('table', { style: { width: '100%' } }, [\n                table\n              ])\n            }\n          })\n        }\n\n        // Autocompletion resolved into one result\n        if (candidates.length === 1) {\n          // Mutating Stdin mutates the cursor, so we've to wait to push it to the end\n          const unwatch = this.$watch(\n            () => this.cursor,\n            () => {\n              this.cursor =\n                cursor +\n                (candidates[0].length - autocompleteableStdin.length + 0)\n\n              unwatch()\n            }\n          )\n\n          this.stdin = candidates[0]\n        }\n\n        return\n      }\n\n      // Check if option might be completed already or option is last tokens\n      if (\n        this.stdin[cursor] !== '' &&\n        this.stdin[cursor] !== ' ' &&\n        typeof this.stdin[cursor] !== 'undefined'\n      ) {\n        return\n      }\n\n      // Get the executable\n      const program = command[0]\n\n      // Check if any autocompleteable exists\n      if (\n        typeof this.options.long[program] === 'undefined' &&\n        typeof this.options.short[program] === 'undefined'\n      ) {\n        return\n      }\n\n      // Autocompleteable is long option\n      if (autocompleteableStdin.substring(0, 2) === '--') {\n        const candidates = []\n        this.options.long[program].forEach((option) => {\n          // If only dashes are presents, user requests all options\n          if (\n            `--${option}`.startsWith(autocompleteableStdin) ||\n            autocompleteableStdin === '--'\n          ) {\n            candidates.push(option)\n          }\n        })\n\n        // Autocompletion resolved into one result\n        if (candidates.length === 1) {\n          const autocompleted = `${this.stdin.substring(0, pointer - 1)} --${\n            candidates[0]\n          }`\n          const rest = `${this.stdin.substring(this.cursor)}`\n\n          // Mutating Stdin mutates the cursor, so we've to wait to push it to the end\n          const unwatch = this.$watch(\n            () => this.cursor,\n            () => {\n              this.cursor =\n                cursor +\n                (candidates[0].length - autocompleteableStdin.length + 2)\n\n              unwatch()\n            }\n          )\n\n          this.stdin = `${autocompleted}${rest}`\n\n          return\n        }\n\n        // Autocompletion resolved into multiple result\n        if (autocompleteableStdin === '--' || candidates.length > 1) {\n          this.history.push({\n            // Build table programmatically\n            render: (createElement) => {\n              const columns = candidates.length < 5 ? candidates.length : 4\n              const rows =\n                candidates.length < 5\n                  ? 1\n                  : Math.ceil(candidates.length / columns)\n\n              let index = 0\n              const table = []\n              for (let i = 0; i < rows; i++) {\n                const row = []\n                for (let j = 0; j < columns; j++) {\n                  row.push(createElement('td', `--${candidates[index]}`))\n                  index++\n                }\n\n                table.push(createElement('tr', [row]))\n              }\n\n              return createElement('table', { style: { width: '100%' } }, [\n                table\n              ])\n            }\n          })\n        }\n\n        return\n      }\n\n      // Autocompleteable is option\n      if (autocompleteableStdin.substring(0, 1) === '-') {\n        const candidates = []\n        this.options.short[program].forEach((option) => {\n          // If only one dash is present, user requests all options\n          if (\n            `-${option}`.startsWith(autocompleteableStdin) ||\n            autocompleteableStdin === '-'\n          ) {\n            candidates.push(option)\n          }\n        })\n\n        // Autocompletion resolved into one result\n        if (candidates.length === 1) {\n          const autocompleted = `${this.stdin.substring(0, pointer - 1)} -${\n            candidates[0]\n          }`\n          const rest = `${this.stdin.substring(this.cursor)}`\n\n          // Mutating Stdin mutates the cursor, so we've to wait to push it to the end\n          const unwatch = this.$watch(\n            () => this.cursor,\n            () => {\n              this.cursor =\n                cursor +\n                (candidates[0].length - autocompleteableStdin.length + 1)\n\n              unwatch()\n            }\n          )\n\n          this.stdin = `${autocompleted}${rest}`\n\n          return\n        }\n\n        // Autocompletion resolved into multiple result\n        if (autocompleteableStdin === '-' || candidates.length > 1) {\n          this.history.push({\n            // Build table programmatically\n            render: (createElement) => {\n              const columns = candidates.length < 5 ? candidates.length : 4\n              const rows =\n                candidates.length < 5\n                  ? 1\n                  : Math.ceil(candidates.length / columns)\n\n              let index = 0\n              const table = []\n              for (let i = 0; i < rows; i++) {\n                const row = []\n                for (let j = 0; j < columns; j++) {\n                  row.push(createElement('td', `-${candidates[index]}`))\n                  index++\n                }\n\n                table.push(createElement('tr', [row]))\n              }\n\n              return createElement('table', { style: { width: '100%' } }, [\n                table\n              ])\n            }\n          })\n        }\n      }\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\">\n* {\n  margin: 0;\n  padding: 0;\n}\nbody {\n  background: #002b36;\n\n  h1,\n  h2,\n  h3 {\n    font-family: \"Inconsolata\", monospace;\n  }\n\n  p {\n    color: #65888c;\n    font-size: 20px;\n    font-family: \"Montserrat\", sans-serif;\n  }\n\n  pre {\n    width: 100%;\n    padding: 0;\n    margin-top: 1em;\n    overflow: auto;\n    overflow-y: hidden;\n\n    code {\n      padding: 10px;\n      color: #333;\n      margin: 5px;\n    }\n  }\n\n  .vue-command {\n    .term-bar {\n      position: fixed;\n      -webkit-touch-callout: none;\n      -webkit-user-select: none;\n      -khtml-user-select: none;\n      -moz-user-select: none;\n      -ms-user-select: none;\n      user-select: none;\n    }\n\n    .term-std {\n      margin-top: 52px;\n      height: 100%;\n    }\n  }\n}\n::-webkit-scrollbar {\n  width: 8px;\n}\n\n::-webkit-scrollbar-track {\n  background: #252525;\n}\n\n::-webkit-scrollbar-thumb {\n  background: #f1f1f1;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: #333;\n}\n</style>\n"]}]}